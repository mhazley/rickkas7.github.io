<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PublishQueueAsyncRK: PublishQueueAsyncFRAM Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PublishQueueAsyncRK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">PublishQueueAsyncFRAM Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Support for MB85RC256V-FRAM-RK library.  
 <a href="class_publish_queue_async_f_r_a_m.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_publish_queue_async_r_k_8h_source.html">PublishQueueAsyncRK.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PublishQueueAsyncFRAM:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_publish_queue_async_f_r_a_m.png" usemap="#PublishQueueAsyncFRAM_map" alt=""/>
  <map id="PublishQueueAsyncFRAM_map" name="PublishQueueAsyncFRAM_map">
<area href="class_publish_queue_async_base.html" title="Abstract base class for async publish queue. " alt="PublishQueueAsyncBase" shape="rect" coords="0,0,163,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa6518b052e1939bb027e50d6fd5cf68c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_f_r_a_m.html#aa6518b052e1939bb027e50d6fd5cf68c">PublishQueueAsyncFRAM</a> (MB85RC256V &amp;<a class="el" href="class_publish_queue_async_f_r_a_m.html#aec812dd76bc47ebbfd4d8550dedefaf5">fram</a>, size_t <a class="el" href="class_publish_queue_async_f_r_a_m.html#a950f1b56b24011598e6564c1026e8033">start</a>=0, size_t <a class="el" href="class_publish_queue_async_f_r_a_m.html#a31a6e8848f788f5012c1566d3980e226">len</a>=MB85RC256V::MEMORY_SIZE)</td></tr>
<tr class="memdesc:aa6518b052e1939bb027e50d6fd5cf68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrctor for FRAM base class.  <a href="#aa6518b052e1939bb027e50d6fd5cf68c">More...</a><br /></td></tr>
<tr class="separator:aa6518b052e1939bb027e50d6fd5cf68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55adc74cb489e5c1d2ae40ba655a474a"><td class="memItemLeft" align="right" valign="top"><a id="a55adc74cb489e5c1d2ae40ba655a474a"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_f_r_a_m.html#a55adc74cb489e5c1d2ae40ba655a474a">~PublishQueueAsyncFRAM</a> ()</td></tr>
<tr class="memdesc:a55adc74cb489e5c1d2ae40ba655a474a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. You norrmally allocate one of these as a global variable and don't delete it. <br /></td></tr>
<tr class="separator:a55adc74cb489e5c1d2ae40ba655a474a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013ceb1b5b448878285371c60638457f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_f_r_a_m.html#a013ceb1b5b448878285371c60638457f">setup</a> ()</td></tr>
<tr class="memdesc:a013ceb1b5b448878285371c60638457f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the thread. You must call this from setup.  <a href="#a013ceb1b5b448878285371c60638457f">More...</a><br /></td></tr>
<tr class="separator:a013ceb1b5b448878285371c60638457f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38d3734e5480be842062a74c4b4cbac"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_f_r_a_m.html#ab38d3734e5480be842062a74c4b4cbac">publishCommon</a> (const char *eventName, const char *data, int ttl, PublishFlags flags1, PublishFlags flags2=PublishFlags())</td></tr>
<tr class="memdesc:ab38d3734e5480be842062a74c4b4cbac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common publish function. All other overloads lead here. This is a pure virtual function, implemented in subclasses.  <a href="#ab38d3734e5480be842062a74c4b4cbac">More...</a><br /></td></tr>
<tr class="separator:ab38d3734e5480be842062a74c4b4cbac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778e30bcaef0c1f171a1571f10d88586"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_publish_queue_event_data.html">PublishQueueEventData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_f_r_a_m.html#a778e30bcaef0c1f171a1571f10d88586">getOldestEvent</a> ()</td></tr>
<tr class="memdesc:a778e30bcaef0c1f171a1571f10d88586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the oldest event that hasn't been published yet.  <a href="#a778e30bcaef0c1f171a1571f10d88586">More...</a><br /></td></tr>
<tr class="separator:a778e30bcaef0c1f171a1571f10d88586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af068a2531ce0516bdba3dcaf30ced498"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_f_r_a_m.html#af068a2531ce0516bdba3dcaf30ced498">clearEvents</a> ()</td></tr>
<tr class="memdesc:af068a2531ce0516bdba3dcaf30ced498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove any saved events.  <a href="#af068a2531ce0516bdba3dcaf30ced498">More...</a><br /></td></tr>
<tr class="separator:af068a2531ce0516bdba3dcaf30ced498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b23a7caaf7e70689217fd5ce9fd9d73"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_f_r_a_m.html#a3b23a7caaf7e70689217fd5ce9fd9d73">discardOldEvent</a> (bool secondEvent)</td></tr>
<tr class="memdesc:a3b23a7caaf7e70689217fd5ce9fd9d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discards the oldest event or second oldest event.  <a href="#a3b23a7caaf7e70689217fd5ce9fd9d73">More...</a><br /></td></tr>
<tr class="separator:a3b23a7caaf7e70689217fd5ce9fd9d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811d3549ac6f62fc6f5cee2caf0c04ce"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_f_r_a_m.html#a811d3549ac6f62fc6f5cee2caf0c04ce">skipEvent</a> (size_t addr, uint8_t *buf)</td></tr>
<tr class="memdesc:a811d3549ac6f62fc6f5cee2caf0c04ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an address in FRAM, finds the offset of the next event.  <a href="#a811d3549ac6f62fc6f5cee2caf0c04ce">More...</a><br /></td></tr>
<tr class="separator:a811d3549ac6f62fc6f5cee2caf0c04ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_publish_queue_async_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_publish_queue_async_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_publish_queue_async_base.html">PublishQueueAsyncBase</a></td></tr>
<tr class="memitem:a0f99925ab8cba714e54364adb80a2582 inherit pub_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="a0f99925ab8cba714e54364adb80a2582"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a0f99925ab8cba714e54364adb80a2582">PublishQueueAsyncBase</a> ()</td></tr>
<tr class="memdesc:a0f99925ab8cba714e54364adb80a2582 inherit pub_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a publish queue. <br /></td></tr>
<tr class="separator:a0f99925ab8cba714e54364adb80a2582 inherit pub_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29fb8c23ba93bbade9c176fce84ef9c inherit pub_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="ae29fb8c23ba93bbade9c176fce84ef9c"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#ae29fb8c23ba93bbade9c176fce84ef9c">~PublishQueueAsyncBase</a> ()</td></tr>
<tr class="memdesc:ae29fb8c23ba93bbade9c176fce84ef9c inherit pub_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">You normally allocate this as a global object and never delete it. <br /></td></tr>
<tr class="separator:ae29fb8c23ba93bbade9c176fce84ef9c inherit pub_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b6306491fc1c4993677f7a09373040 inherit pub_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#ab9b6306491fc1c4993677f7a09373040">publish</a> (const char *eventName, PublishFlags flags1, PublishFlags flags2=PublishFlags())</td></tr>
<tr class="memdesc:ab9b6306491fc1c4993677f7a09373040 inherit pub_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for publishing an event.  <a href="class_publish_queue_async_base.html#ab9b6306491fc1c4993677f7a09373040">More...</a><br /></td></tr>
<tr class="separator:ab9b6306491fc1c4993677f7a09373040 inherit pub_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd76b1db3e72968c899a6d25cda385ac inherit pub_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#abd76b1db3e72968c899a6d25cda385ac">publish</a> (const char *eventName, const char *data, PublishFlags flags1, PublishFlags flags2=PublishFlags())</td></tr>
<tr class="memdesc:abd76b1db3e72968c899a6d25cda385ac inherit pub_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for publishing an event.  <a href="class_publish_queue_async_base.html#abd76b1db3e72968c899a6d25cda385ac">More...</a><br /></td></tr>
<tr class="separator:abd76b1db3e72968c899a6d25cda385ac inherit pub_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386c05f3d4f78e8b18d52c77fcd7d03a inherit pub_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a386c05f3d4f78e8b18d52c77fcd7d03a">publish</a> (const char *eventName, const char *data, int ttl, PublishFlags flags1, PublishFlags flags2=PublishFlags())</td></tr>
<tr class="memdesc:a386c05f3d4f78e8b18d52c77fcd7d03a inherit pub_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for publishing an event.  <a href="class_publish_queue_async_base.html#a386c05f3d4f78e8b18d52c77fcd7d03a">More...</a><br /></td></tr>
<tr class="separator:a386c05f3d4f78e8b18d52c77fcd7d03a inherit pub_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293b9cbbb28c8df2ee3d4dcd631c8288 inherit pub_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_publish_queue_async_base.html">PublishQueueAsyncBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a293b9cbbb28c8df2ee3d4dcd631c8288">withFailureRetryMs</a> (unsigned long value)</td></tr>
<tr class="memdesc:a293b9cbbb28c8df2ee3d4dcd631c8288 inherit pub_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the retry after publish failure time.  <a href="class_publish_queue_async_base.html#a293b9cbbb28c8df2ee3d4dcd631c8288">More...</a><br /></td></tr>
<tr class="separator:a293b9cbbb28c8df2ee3d4dcd631c8288 inherit pub_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70c0a7eada8a75ea376b134baf66dd0 inherit pub_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#aa70c0a7eada8a75ea376b134baf66dd0">setPausePublishing</a> (bool pause)</td></tr>
<tr class="memdesc:aa70c0a7eada8a75ea376b134baf66dd0 inherit pub_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause publishing, even if it would be allowed because the cloud is connected.  <a href="class_publish_queue_async_base.html#aa70c0a7eada8a75ea376b134baf66dd0">More...</a><br /></td></tr>
<tr class="separator:aa70c0a7eada8a75ea376b134baf66dd0 inherit pub_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8da81748f9fdb1925254a67126f465e inherit pub_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#ab8da81748f9fdb1925254a67126f465e">getPausePublishing</a> () const</td></tr>
<tr class="memdesc:ab8da81748f9fdb1925254a67126f465e inherit pub_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if publishing is manually paused.  <a href="class_publish_queue_async_base.html#ab8da81748f9fdb1925254a67126f465e">More...</a><br /></td></tr>
<tr class="separator:ab8da81748f9fdb1925254a67126f465e inherit pub_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4e10fcf529d6d477cda3a2abb0a2ff inherit pub_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a4e4e10fcf529d6d477cda3a2abb0a2ff">mutexLock</a> () const</td></tr>
<tr class="memdesc:a4e4e10fcf529d6d477cda3a2abb0a2ff inherit pub_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a mutex lock.  <a href="class_publish_queue_async_base.html#a4e4e10fcf529d6d477cda3a2abb0a2ff">More...</a><br /></td></tr>
<tr class="separator:a4e4e10fcf529d6d477cda3a2abb0a2ff inherit pub_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3410502e46602fe26aa2fe372663119 inherit pub_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="af3410502e46602fe26aa2fe372663119"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#af3410502e46602fe26aa2fe372663119">mutexUnlock</a> () const</td></tr>
<tr class="memdesc:af3410502e46602fe26aa2fe372663119 inherit pub_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the mutex. <br /></td></tr>
<tr class="separator:af3410502e46602fe26aa2fe372663119 inherit pub_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aec812dd76bc47ebbfd4d8550dedefaf5"><td class="memItemLeft" align="right" valign="top"><a id="aec812dd76bc47ebbfd4d8550dedefaf5"></a>
MB85RC256V &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_f_r_a_m.html#aec812dd76bc47ebbfd4d8550dedefaf5">fram</a></td></tr>
<tr class="memdesc:aec812dd76bc47ebbfd4d8550dedefaf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object for the FRAM. <br /></td></tr>
<tr class="separator:aec812dd76bc47ebbfd4d8550dedefaf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950f1b56b24011598e6564c1026e8033"><td class="memItemLeft" align="right" valign="top"><a id="a950f1b56b24011598e6564c1026e8033"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_f_r_a_m.html#a950f1b56b24011598e6564c1026e8033">start</a></td></tr>
<tr class="memdesc:a950f1b56b24011598e6564c1026e8033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start offset (0 = beginning of FRAM) <br /></td></tr>
<tr class="separator:a950f1b56b24011598e6564c1026e8033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a6e8848f788f5012c1566d3980e226"><td class="memItemLeft" align="right" valign="top"><a id="a31a6e8848f788f5012c1566d3980e226"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_f_r_a_m.html#a31a6e8848f788f5012c1566d3980e226">len</a></td></tr>
<tr class="memdesc:a31a6e8848f788f5012c1566d3980e226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length to use (relative to start!) <br /></td></tr>
<tr class="separator:a31a6e8848f788f5012c1566d3980e226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269e9207d26224ab8ce0b1f2003fffe5"><td class="memItemLeft" align="right" valign="top"><a id="a269e9207d26224ab8ce0b1f2003fffe5"></a>
<a class="el" href="struct_publish_queue_header.html">PublishQueueHeader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_f_r_a_m.html#a269e9207d26224ab8ce0b1f2003fffe5">header</a></td></tr>
<tr class="memdesc:a269e9207d26224ab8ce0b1f2003fffe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The header, copied from FRAM. <br /></td></tr>
<tr class="separator:a269e9207d26224ab8ce0b1f2003fffe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f01c035fa85857f4ee61bb9501d51f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_f_r_a_m.html#af3f01c035fa85857f4ee61bb9501d51f">eventBuf</a> [<a class="el" href="class_publish_queue_async_base.html#a82da94a25de2e3d51fca16f41082c5ff">EVENT_BUF_SIZE</a>]</td></tr>
<tr class="memdesc:af3f01c035fa85857f4ee61bb9501d51f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This holds a single event during scanning and writing.  <a href="#af3f01c035fa85857f4ee61bb9501d51f">More...</a><br /></td></tr>
<tr class="separator:af3f01c035fa85857f4ee61bb9501d51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad41340b04da9b3b89d54f094c05824"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_f_r_a_m.html#aaad41340b04da9b3b89d54f094c05824">publishBuf</a> [<a class="el" href="class_publish_queue_async_base.html#a82da94a25de2e3d51fca16f41082c5ff">EVENT_BUF_SIZE</a>]</td></tr>
<tr class="memdesc:aaad41340b04da9b3b89d54f094c05824"><td class="mdescLeft">&#160;</td><td class="mdescRight">This holds a single event during publish.  <a href="#aaad41340b04da9b3b89d54f094c05824">More...</a><br /></td></tr>
<tr class="separator:aaad41340b04da9b3b89d54f094c05824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf75a4308fe38e775f9a470d4100d765"><td class="memItemLeft" align="right" valign="top"><a id="aaf75a4308fe38e775f9a470d4100d765"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_f_r_a_m.html#aaf75a4308fe38e775f9a470d4100d765">nextFree</a> = 0</td></tr>
<tr class="memdesc:aaf75a4308fe38e775f9a470d4100d765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset of the next free entry in FRAM. This includes "start" so don't add it again! <br /></td></tr>
<tr class="separator:aaf75a4308fe38e775f9a470d4100d765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_publish_queue_async_base"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_publish_queue_async_base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_publish_queue_async_base.html">PublishQueueAsyncBase</a></td></tr>
<tr class="memitem:a72689e01ab54e418c06bcd110b042bc6 inherit pro_attribs_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="a72689e01ab54e418c06bcd110b042bc6"></a>
Thread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a72689e01ab54e418c06bcd110b042bc6">thread</a> = NULL</td></tr>
<tr class="memdesc:a72689e01ab54e418c06bcd110b042bc6 inherit pro_attribs_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread object, created in <a class="el" href="class_publish_queue_async_base.html#a1aa68c33946bf13ed4d9c15ed7e471d4" title="Start the thread. You must call this from setup. ">setup()</a> <br /></td></tr>
<tr class="separator:a72689e01ab54e418c06bcd110b042bc6 inherit pro_attribs_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f9981e0546e787ca6efc0253d36050 inherit pro_attribs_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="a00f9981e0546e787ca6efc0253d36050"></a>
os_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a00f9981e0546e787ca6efc0253d36050">mutex</a></td></tr>
<tr class="memdesc:a00f9981e0546e787ca6efc0253d36050 inherit pro_attribs_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex to protect against concurrent access, created in <a class="el" href="class_publish_queue_async_base.html#a1aa68c33946bf13ed4d9c15ed7e471d4" title="Start the thread. You must call this from setup. ">setup()</a> <br /></td></tr>
<tr class="separator:a00f9981e0546e787ca6efc0253d36050 inherit pro_attribs_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325d1178a41cd127817ccd642e36e4f0 inherit pro_attribs_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a325d1178a41cd127817ccd642e36e4f0">failureRetryMs</a> = 30000</td></tr>
<tr class="memdesc:a325d1178a41cd127817ccd642e36e4f0 inherit pro_attribs_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default time to wait before trying to publish again after failure.  <a href="class_publish_queue_async_base.html#a325d1178a41cd127817ccd642e36e4f0">More...</a><br /></td></tr>
<tr class="separator:a325d1178a41cd127817ccd642e36e4f0 inherit pro_attribs_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d1c3bfb3f31f4149f6f77240b7b805 inherit pro_attribs_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="class_publish_queue_async_base.html">PublishQueueAsyncBase</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a84d1c3bfb3f31f4149f6f77240b7b805">stateHandler</a> = &amp;<a class="el" href="class_publish_queue_async_base.html#a4453a1e7c146338c3a7adaf66f47e379">PublishQueueAsyncBase::startState</a></td></tr>
<tr class="memdesc:a84d1c3bfb3f31f4149f6f77240b7b805 inherit pro_attribs_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">State handler function pointer.  <a href="class_publish_queue_async_base.html#a84d1c3bfb3f31f4149f6f77240b7b805">More...</a><br /></td></tr>
<tr class="separator:a84d1c3bfb3f31f4149f6f77240b7b805 inherit pro_attribs_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac136d0f2dd73551add270db06414ef18 inherit pro_attribs_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="ac136d0f2dd73551add270db06414ef18"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#ac136d0f2dd73551add270db06414ef18">stateTime</a> = 0</td></tr>
<tr class="memdesc:ac136d0f2dd73551add270db06414ef18 inherit pro_attribs_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last millis value for certain state changes like waitRetryState. <br /></td></tr>
<tr class="separator:ac136d0f2dd73551add270db06414ef18 inherit pro_attribs_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ad0d79d7740865ddbc5a257937e405 inherit pro_attribs_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="a25ad0d79d7740865ddbc5a257937e405"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a25ad0d79d7740865ddbc5a257937e405">lastPublish</a> = 0</td></tr>
<tr class="memdesc:a25ad0d79d7740865ddbc5a257937e405 inherit pro_attribs_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">milis() value for the last publish, used to control the frequency of publishes <br /></td></tr>
<tr class="separator:a25ad0d79d7740865ddbc5a257937e405 inherit pro_attribs_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7d6c7aa1915d65af7670f4bcdf1445 inherit pro_attribs_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a0c7d6c7aa1915d65af7670f4bcdf1445">isSending</a> = false</td></tr>
<tr class="memdesc:a0c7d6c7aa1915d65af7670f4bcdf1445 inherit pro_attribs_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if we're currently publishing  <a href="class_publish_queue_async_base.html#a0c7d6c7aa1915d65af7670f4bcdf1445">More...</a><br /></td></tr>
<tr class="separator:a0c7d6c7aa1915d65af7670f4bcdf1445 inherit pro_attribs_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2223328a03338c3f8ef59dbbdb2e8fab inherit pro_attribs_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a2223328a03338c3f8ef59dbbdb2e8fab">haveSetup</a> = false</td></tr>
<tr class="memdesc:a2223328a03338c3f8ef59dbbdb2e8fab inherit pro_attribs_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if <a class="el" href="class_publish_queue_async_base.html#a1aa68c33946bf13ed4d9c15ed7e471d4" title="Start the thread. You must call this from setup. ">setup()</a> has been called.  <a href="class_publish_queue_async_base.html#a2223328a03338c3f8ef59dbbdb2e8fab">More...</a><br /></td></tr>
<tr class="separator:a2223328a03338c3f8ef59dbbdb2e8fab inherit pro_attribs_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f0e2c9b8a50fa156161ca567e29abd inherit pro_attribs_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="ae8f0e2c9b8a50fa156161ca567e29abd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#ae8f0e2c9b8a50fa156161ca567e29abd">pausePublishing</a> = false</td></tr>
<tr class="memdesc:ae8f0e2c9b8a50fa156161ca567e29abd inherit pro_attribs_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if publishing has been manually paused. <br /></td></tr>
<tr class="separator:ae8f0e2c9b8a50fa156161ca567e29abd inherit pro_attribs_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_class_publish_queue_async_base"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_class_publish_queue_async_base')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="class_publish_queue_async_base.html">PublishQueueAsyncBase</a></td></tr>
<tr class="memitem:a82da94a25de2e3d51fca16f41082c5ff inherit pub_static_attribs_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a82da94a25de2e3d51fca16f41082c5ff">EVENT_BUF_SIZE</a> = sizeof(<a class="el" href="struct_publish_queue_event_data.html">PublishQueueEventData</a>) + 65 + 623</td></tr>
<tr class="memdesc:a82da94a25de2e3d51fca16f41082c5ff inherit pub_static_attribs_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of <a class="el" href="struct_publish_queue_event_data.html" title="Event data structure. ">PublishQueueEventData</a> with strings (696 bytes)  <a href="class_publish_queue_async_base.html#a82da94a25de2e3d51fca16f41082c5ff">More...</a><br /></td></tr>
<tr class="separator:a82da94a25de2e3d51fca16f41082c5ff inherit pub_static_attribs_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_publish_queue_async_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_publish_queue_async_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_publish_queue_async_base.html">PublishQueueAsyncBase</a></td></tr>
<tr class="memitem:a7763faadc5d19fd82ea917a40d8eea35 inherit pro_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="a7763faadc5d19fd82ea917a40d8eea35"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a7763faadc5d19fd82ea917a40d8eea35">threadFunction</a> ()</td></tr>
<tr class="memdesc:a7763faadc5d19fd82ea917a40d8eea35 inherit pro_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The thread function for the publish thread. <br /></td></tr>
<tr class="separator:a7763faadc5d19fd82ea917a40d8eea35 inherit pro_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4453a1e7c146338c3a7adaf66f47e379 inherit pro_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="a4453a1e7c146338c3a7adaf66f47e379"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a4453a1e7c146338c3a7adaf66f47e379">startState</a> ()</td></tr>
<tr class="memdesc:a4453a1e7c146338c3a7adaf66f47e379 inherit pro_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker thread state machine start handler. <br /></td></tr>
<tr class="separator:a4453a1e7c146338c3a7adaf66f47e379 inherit pro_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c12f03f12cd437e1406f868b6a3158 inherit pro_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="a36c12f03f12cd437e1406f868b6a3158"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a36c12f03f12cd437e1406f868b6a3158">checkQueueState</a> ()</td></tr>
<tr class="memdesc:a36c12f03f12cd437e1406f868b6a3158 inherit pro_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker thread state machine check queue state handler. <br /></td></tr>
<tr class="separator:a36c12f03f12cd437e1406f868b6a3158 inherit pro_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd57e900a77d9250228d852fba06c26 inherit pro_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="a4dd57e900a77d9250228d852fba06c26"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a4dd57e900a77d9250228d852fba06c26">waitRetryState</a> ()</td></tr>
<tr class="memdesc:a4dd57e900a77d9250228d852fba06c26 inherit pro_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker thread state machine wait to retry publishing state handler. <br /></td></tr>
<tr class="separator:a4dd57e900a77d9250228d852fba06c26 inherit pro_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_class_publish_queue_async_base"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_class_publish_queue_async_base')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="class_publish_queue_async_base.html">PublishQueueAsyncBase</a></td></tr>
<tr class="memitem:a38f573ef4ae69b3e38a82bd3036d3e7a inherit pro_static_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="a38f573ef4ae69b3e38a82bd3036d3e7a"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a38f573ef4ae69b3e38a82bd3036d3e7a">threadFunctionStatic</a> (void *param)</td></tr>
<tr class="memdesc:a38f573ef4ae69b3e38a82bd3036d3e7a inherit pro_static_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static version of the thread function. <br /></td></tr>
<tr class="separator:a38f573ef4ae69b3e38a82bd3036d3e7a inherit pro_static_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Support for MB85RC256V-FRAM-RK library. </p>
<p>If you include "MB85RC256V-FRAM-RK.h" before <a class="el" href="_publish_queue_async_r_k_8h_source.html">PublishQueueAsyncRK.h</a>, this code will be enabled </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa6518b052e1939bb027e50d6fd5cf68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6518b052e1939bb027e50d6fd5cf68c">&#9670;&nbsp;</a></span>PublishQueueAsyncFRAM()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PublishQueueAsyncFRAM::PublishQueueAsyncFRAM </td>
          <td>(</td>
          <td class="paramtype">MB85RC256V &amp;&#160;</td>
          <td class="paramname"><em>fram</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em> = <code>MB85RC256V::MEMORY_SIZE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrctor for FRAM base class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fram</td><td>The MB85RC256V object for the FRAM. You must call begin() on the FRAM before calling <a class="el" href="class_publish_queue_async_f_r_a_m.html#a013ceb1b5b448878285371c60638457f" title="Start the thread. You must call this from setup. ">setup()</a> on this object.</td></tr>
    <tr><td class="paramname">start</td><td>Optional start address, default is 0 (beginning of FRAM)</td></tr>
    <tr><td class="paramname">len</td><td>Optional length, default is size of FRAM. Note that this is a length, not an ending address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af068a2531ce0516bdba3dcaf30ced498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af068a2531ce0516bdba3dcaf30ced498">&#9670;&nbsp;</a></span>clearEvents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PublishQueueAsyncFRAM::clearEvents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove any saved events. </p>
<dl class="section return"><dt>Returns</dt><dd>Always returns true.</dd></dl>
<p>Since the FRAM code copies the event being published to a separate buffer, the events can always be cleared. </p>

<p>Implements <a class="el" href="class_publish_queue_async_base.html#ac9b8f93f878db4c2dfce2ab17ec4bf05">PublishQueueAsyncBase</a>.</p>

</div>
</div>
<a id="a3b23a7caaf7e70689217fd5ce9fd9d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b23a7caaf7e70689217fd5ce9fd9d73">&#9670;&nbsp;</a></span>discardOldEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PublishQueueAsyncFRAM::discardOldEvent </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>secondEvent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discards the oldest event or second oldest event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">secondEvent</td><td>True to discard the second oldest event</td></tr>
  </table>
  </dd>
</dl>
<p>When using retained memory, the <a class="el" href="class_publish_queue_async_f_r_a_m.html#a778e30bcaef0c1f171a1571f10d88586" title="Get the oldest event that hasn&#39;t been published yet. ">getOldestEvent()</a> function returns a pointer to retained memory. This pointer must remain valid while in the process of publishing. If the retained buffer is full, we want to discard and old event to make room for a newer event, but we can't dispose of the oldest event, because it may be in use, so we pass true for secondEvent. </p>

<p>Implements <a class="el" href="class_publish_queue_async_base.html#a4ff4ebefebf8f89c41b3e13641c2a2b5">PublishQueueAsyncBase</a>.</p>

</div>
</div>
<a id="a778e30bcaef0c1f171a1571f10d88586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778e30bcaef0c1f171a1571f10d88586">&#9670;&nbsp;</a></span>getOldestEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_publish_queue_event_data.html">PublishQueueEventData</a>* PublishQueueAsyncFRAM::getOldestEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the oldest event that hasn't been published yet. </p>
<p>Returns a pointer to a <a class="el" href="struct_publish_queue_event_data.html" title="Event data structure. ">PublishQueueEventData</a> structure in the publishBuf member variable. This will remain valid until <a class="el" href="class_publish_queue_async_f_r_a_m.html#a778e30bcaef0c1f171a1571f10d88586" title="Get the oldest event that hasn&#39;t been published yet. ">getOldestEvent()</a> is called again. </p>

<p>Implements <a class="el" href="class_publish_queue_async_base.html#a010258715d59b28c1352ff56d9ccf495">PublishQueueAsyncBase</a>.</p>

</div>
</div>
<a id="ab38d3734e5480be842062a74c4b4cbac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38d3734e5480be842062a74c4b4cbac">&#9670;&nbsp;</a></span>publishCommon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PublishQueueAsyncFRAM::publishCommon </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eventName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ttl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublishFlags&#160;</td>
          <td class="paramname"><em>flags1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublishFlags&#160;</td>
          <td class="paramname"><em>flags2</em> = <code>PublishFlags()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Common publish function. All other overloads lead here. This is a pure virtual function, implemented in subclasses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventName</td><td>The name of the event (63 character maximum).</td></tr>
    <tr><td class="paramname">data</td><td>The event data (255 bytes maximum, 622 bytes in system firmware 0.8.0-rc.4 and later).</td></tr>
    <tr><td class="paramname">ttl</td><td>The time-to-live value. If not specified in one of the other overloads, the value 60 is used. However, the ttl is ignored by the cloud, so it doesn't matter what you set it to. Essentially all events are discarded immediately if not subscribed to so they essentially have a ttl of 0.</td></tr>
    <tr><td class="paramname">flags1</td><td>Normally PRIVATE. You can also use PUBLIC, but one or the other must be specified.</td></tr>
    <tr><td class="paramname">flags2</td><td>(optional) You can use NO_ACK or WITH_ACK if desired.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the event was queued or false if it was not.</dd></dl>
<p>This function almost always returns true. If you queue more events than fit in the buffer the oldest (sometimes second oldest) is discarded. </p>

<p>Implements <a class="el" href="class_publish_queue_async_base.html#a9fd5556a87ef87adacb215f7b9ae03af">PublishQueueAsyncBase</a>.</p>

</div>
</div>
<a id="a013ceb1b5b448878285371c60638457f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013ceb1b5b448878285371c60638457f">&#9670;&nbsp;</a></span>setup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PublishQueueAsyncFRAM::setup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start the thread. You must call this from setup. </p>
<p>Since version 0.0.1 did not have the setup method, if you don't <a class="el" href="class_publish_queue_async_f_r_a_m.html#a013ceb1b5b448878285371c60638457f" title="Start the thread. You must call this from setup. ">setup()</a> it will be set up when you first publish, but starting the thread earlier is suggested, but only with retained memory (<a class="el" href="class_publish_queue_async.html" title="Backward compatible API so code build for version 0.0.5 and earlier will still compile. ">PublishQueueAsync</a>).</p>
<p>In 0.1.0 or later you must call <a class="el" href="class_publish_queue_async_f_r_a_m.html#a013ceb1b5b448878285371c60638457f" title="Start the thread. You must call this from setup. ">setup()</a>, or the library will not function with FRAM, Spiffs, or SdFat. </p>

<p>Reimplemented from <a class="el" href="class_publish_queue_async_base.html#a1aa68c33946bf13ed4d9c15ed7e471d4">PublishQueueAsyncBase</a>.</p>

</div>
</div>
<a id="a811d3549ac6f62fc6f5cee2caf0c04ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a811d3549ac6f62fc6f5cee2caf0c04ce">&#9670;&nbsp;</a></span>skipEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t PublishQueueAsyncFRAM::skipEvent </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an address in FRAM, finds the offset of the next event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Where to start (address in FRAM, not relative to start!)</td></tr>
    <tr><td class="paramname">buf</td><td>Buffer to store the event in. Typically either eventBuf or publishBuf.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address of the the next event </dd></dl>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="af3f01c035fa85857f4ee61bb9501d51f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f01c035fa85857f4ee61bb9501d51f">&#9670;&nbsp;</a></span>eventBuf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t PublishQueueAsyncFRAM::eventBuf[<a class="el" href="class_publish_queue_async_base.html#a82da94a25de2e3d51fca16f41082c5ff">EVENT_BUF_SIZE</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This holds a single event during scanning and writing. </p>
<p>Because the data needs to be in RAM to be written to FRAM, this buffer is required. </p>

</div>
</div>
<a id="aaad41340b04da9b3b89d54f094c05824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad41340b04da9b3b89d54f094c05824">&#9670;&nbsp;</a></span>publishBuf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t PublishQueueAsyncFRAM::publishBuf[<a class="el" href="class_publish_queue_async_base.html#a82da94a25de2e3d51fca16f41082c5ff">EVENT_BUF_SIZE</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This holds a single event during publish. </p>
<p>Because the publish code does not copy the data, we need to keep the data around even after <a class="el" href="class_publish_queue_async_f_r_a_m.html#a778e30bcaef0c1f171a1571f10d88586" title="Get the oldest event that hasn&#39;t been published yet. ">getOldestEvent()</a> returns. This is the buffer that holds the data.</p>
<p>It's separate from eventBuf because eventBuf is used to publish new data to the queue. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="_publish_queue_async_r_k_8h_source.html">PublishQueueAsyncRK.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
