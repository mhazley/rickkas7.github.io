<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PublishQueueAsyncRK: PublishQueueAsyncRetained Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PublishQueueAsyncRK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">PublishQueueAsyncRetained Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class to store the publish queue in retained memory.  
 <a href="class_publish_queue_async_retained.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_publish_queue_async_r_k_8h_source.html">PublishQueueAsyncRK.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PublishQueueAsyncRetained:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_publish_queue_async_retained.png" usemap="#PublishQueueAsyncRetained_map" alt=""/>
  <map id="PublishQueueAsyncRetained_map" name="PublishQueueAsyncRetained_map">
<area href="class_publish_queue_async_base.html" title="Abstract base class for async publish queue. " alt="PublishQueueAsyncBase" shape="rect" coords="0,0,176,24"/>
<area href="class_publish_queue_async.html" title="Backward compatible API so code build for version 0.0.5 and earlier will still compile. " alt="PublishQueueAsync" shape="rect" coords="0,112,176,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aea133e2e65b810832aa4dcddb9f16542"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_retained.html#aea133e2e65b810832aa4dcddb9f16542">PublishQueueAsyncRetained</a> (uint8_t *<a class="el" href="class_publish_queue_async_retained.html#ab6ccd04ccaa011ef86d4c179ce450979">retainedBuffer</a>, uint16_t <a class="el" href="class_publish_queue_async_retained.html#a5c27b445b5f8a1fdec3c2cb67124a743">retainedBufferSize</a>)</td></tr>
<tr class="memdesc:aea133e2e65b810832aa4dcddb9f16542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a publish queue.  <a href="#aea133e2e65b810832aa4dcddb9f16542">More...</a><br /></td></tr>
<tr class="separator:aea133e2e65b810832aa4dcddb9f16542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3573d5250aeb4f5f69fcc677a6591e19"><td class="memItemLeft" align="right" valign="top"><a id="a3573d5250aeb4f5f69fcc677a6591e19"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_retained.html#a3573d5250aeb4f5f69fcc677a6591e19">~PublishQueueAsyncRetained</a> ()</td></tr>
<tr class="memdesc:a3573d5250aeb4f5f69fcc677a6591e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">You normally allocate this as a global object and never delete it. <br /></td></tr>
<tr class="separator:a3573d5250aeb4f5f69fcc677a6591e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094ca07795be1f7a5c694090d5c294db"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_retained.html#a094ca07795be1f7a5c694090d5c294db">publishCommon</a> (const char *eventName, const char *data, int ttl, PublishFlags flags1, PublishFlags flags2=PublishFlags())</td></tr>
<tr class="memdesc:a094ca07795be1f7a5c694090d5c294db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish an event. All other overloads lead here.  <a href="#a094ca07795be1f7a5c694090d5c294db">More...</a><br /></td></tr>
<tr class="separator:a094ca07795be1f7a5c694090d5c294db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5db84095bf507fc93de724e434105f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_publish_queue_event_data.html">PublishQueueEventData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_retained.html#a6b5db84095bf507fc93de724e434105f">getOldestEvent</a> ()</td></tr>
<tr class="memdesc:a6b5db84095bf507fc93de724e434105f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the oldest event that hasn't been published yet.  <a href="#a6b5db84095bf507fc93de724e434105f">More...</a><br /></td></tr>
<tr class="separator:a6b5db84095bf507fc93de724e434105f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43b9eb856d90539ff5caacd3fbe46e0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_retained.html#af43b9eb856d90539ff5caacd3fbe46e0">clearEvents</a> ()</td></tr>
<tr class="memdesc:af43b9eb856d90539ff5caacd3fbe46e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove any saved events.  <a href="#af43b9eb856d90539ff5caacd3fbe46e0">More...</a><br /></td></tr>
<tr class="separator:af43b9eb856d90539ff5caacd3fbe46e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d93482fd77f1cf4a33f0d7494b406b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_retained.html#a86d93482fd77f1cf4a33f0d7494b406b">discardOldEvent</a> (bool secondEvent)</td></tr>
<tr class="memdesc:a86d93482fd77f1cf4a33f0d7494b406b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discards the oldest event or second oldest event.  <a href="#a86d93482fd77f1cf4a33f0d7494b406b">More...</a><br /></td></tr>
<tr class="separator:a86d93482fd77f1cf4a33f0d7494b406b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49fe10a9710aeffee1f0e80b8d71a548"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_retained.html#a49fe10a9710aeffee1f0e80b8d71a548">skipEvent</a> (uint8_t *start)</td></tr>
<tr class="memdesc:a49fe10a9710aeffee1f0e80b8d71a548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a pointer into the retained buffer, finds the offset of the next event.  <a href="#a49fe10a9710aeffee1f0e80b8d71a548">More...</a><br /></td></tr>
<tr class="separator:a49fe10a9710aeffee1f0e80b8d71a548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_publish_queue_async_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_publish_queue_async_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_publish_queue_async_base.html">PublishQueueAsyncBase</a></td></tr>
<tr class="memitem:a0f99925ab8cba714e54364adb80a2582 inherit pub_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="a0f99925ab8cba714e54364adb80a2582"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a0f99925ab8cba714e54364adb80a2582">PublishQueueAsyncBase</a> ()</td></tr>
<tr class="memdesc:a0f99925ab8cba714e54364adb80a2582 inherit pub_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a publish queue. <br /></td></tr>
<tr class="separator:a0f99925ab8cba714e54364adb80a2582 inherit pub_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29fb8c23ba93bbade9c176fce84ef9c inherit pub_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="ae29fb8c23ba93bbade9c176fce84ef9c"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#ae29fb8c23ba93bbade9c176fce84ef9c">~PublishQueueAsyncBase</a> ()</td></tr>
<tr class="memdesc:ae29fb8c23ba93bbade9c176fce84ef9c inherit pub_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">You normally allocate this as a global object and never delete it. <br /></td></tr>
<tr class="separator:ae29fb8c23ba93bbade9c176fce84ef9c inherit pub_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa68c33946bf13ed4d9c15ed7e471d4 inherit pub_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a1aa68c33946bf13ed4d9c15ed7e471d4">setup</a> ()</td></tr>
<tr class="memdesc:a1aa68c33946bf13ed4d9c15ed7e471d4 inherit pub_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the thread. You must call this from setup.  <a href="class_publish_queue_async_base.html#a1aa68c33946bf13ed4d9c15ed7e471d4">More...</a><br /></td></tr>
<tr class="separator:a1aa68c33946bf13ed4d9c15ed7e471d4 inherit pub_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b6306491fc1c4993677f7a09373040 inherit pub_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#ab9b6306491fc1c4993677f7a09373040">publish</a> (const char *eventName, PublishFlags flags1, PublishFlags flags2=PublishFlags())</td></tr>
<tr class="memdesc:ab9b6306491fc1c4993677f7a09373040 inherit pub_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for publishing an event.  <a href="class_publish_queue_async_base.html#ab9b6306491fc1c4993677f7a09373040">More...</a><br /></td></tr>
<tr class="separator:ab9b6306491fc1c4993677f7a09373040 inherit pub_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd76b1db3e72968c899a6d25cda385ac inherit pub_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#abd76b1db3e72968c899a6d25cda385ac">publish</a> (const char *eventName, const char *data, PublishFlags flags1, PublishFlags flags2=PublishFlags())</td></tr>
<tr class="memdesc:abd76b1db3e72968c899a6d25cda385ac inherit pub_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for publishing an event.  <a href="class_publish_queue_async_base.html#abd76b1db3e72968c899a6d25cda385ac">More...</a><br /></td></tr>
<tr class="separator:abd76b1db3e72968c899a6d25cda385ac inherit pub_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386c05f3d4f78e8b18d52c77fcd7d03a inherit pub_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a386c05f3d4f78e8b18d52c77fcd7d03a">publish</a> (const char *eventName, const char *data, int ttl, PublishFlags flags1, PublishFlags flags2=PublishFlags())</td></tr>
<tr class="memdesc:a386c05f3d4f78e8b18d52c77fcd7d03a inherit pub_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for publishing an event.  <a href="class_publish_queue_async_base.html#a386c05f3d4f78e8b18d52c77fcd7d03a">More...</a><br /></td></tr>
<tr class="separator:a386c05f3d4f78e8b18d52c77fcd7d03a inherit pub_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293b9cbbb28c8df2ee3d4dcd631c8288 inherit pub_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_publish_queue_async_base.html">PublishQueueAsyncBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a293b9cbbb28c8df2ee3d4dcd631c8288">withFailureRetryMs</a> (unsigned long value)</td></tr>
<tr class="memdesc:a293b9cbbb28c8df2ee3d4dcd631c8288 inherit pub_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the retry after publish failure time.  <a href="class_publish_queue_async_base.html#a293b9cbbb28c8df2ee3d4dcd631c8288">More...</a><br /></td></tr>
<tr class="separator:a293b9cbbb28c8df2ee3d4dcd631c8288 inherit pub_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70c0a7eada8a75ea376b134baf66dd0 inherit pub_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#aa70c0a7eada8a75ea376b134baf66dd0">setPausePublishing</a> (bool pause)</td></tr>
<tr class="memdesc:aa70c0a7eada8a75ea376b134baf66dd0 inherit pub_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause publishing, even if it would be allowed because the cloud is connected.  <a href="class_publish_queue_async_base.html#aa70c0a7eada8a75ea376b134baf66dd0">More...</a><br /></td></tr>
<tr class="separator:aa70c0a7eada8a75ea376b134baf66dd0 inherit pub_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8da81748f9fdb1925254a67126f465e inherit pub_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#ab8da81748f9fdb1925254a67126f465e">getPausePublishing</a> () const</td></tr>
<tr class="memdesc:ab8da81748f9fdb1925254a67126f465e inherit pub_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if publishing is manually paused.  <a href="class_publish_queue_async_base.html#ab8da81748f9fdb1925254a67126f465e">More...</a><br /></td></tr>
<tr class="separator:ab8da81748f9fdb1925254a67126f465e inherit pub_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4e10fcf529d6d477cda3a2abb0a2ff inherit pub_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a4e4e10fcf529d6d477cda3a2abb0a2ff">mutexLock</a> () const</td></tr>
<tr class="memdesc:a4e4e10fcf529d6d477cda3a2abb0a2ff inherit pub_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a mutex lock.  <a href="class_publish_queue_async_base.html#a4e4e10fcf529d6d477cda3a2abb0a2ff">More...</a><br /></td></tr>
<tr class="separator:a4e4e10fcf529d6d477cda3a2abb0a2ff inherit pub_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3410502e46602fe26aa2fe372663119 inherit pub_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="af3410502e46602fe26aa2fe372663119"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#af3410502e46602fe26aa2fe372663119">mutexUnlock</a> () const</td></tr>
<tr class="memdesc:af3410502e46602fe26aa2fe372663119 inherit pub_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the mutex. <br /></td></tr>
<tr class="separator:af3410502e46602fe26aa2fe372663119 inherit pub_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ab6ccd04ccaa011ef86d4c179ce450979"><td class="memItemLeft" align="right" valign="top"><a id="ab6ccd04ccaa011ef86d4c179ce450979"></a>
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_retained.html#ab6ccd04ccaa011ef86d4c179ce450979">retainedBuffer</a></td></tr>
<tr class="memdesc:ab6ccd04ccaa011ef86d4c179ce450979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the beginning of the retained (or regular) RAM buffer. <br /></td></tr>
<tr class="separator:ab6ccd04ccaa011ef86d4c179ce450979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c27b445b5f8a1fdec3c2cb67124a743"><td class="memItemLeft" align="right" valign="top"><a id="a5c27b445b5f8a1fdec3c2cb67124a743"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_retained.html#a5c27b445b5f8a1fdec3c2cb67124a743">retainedBufferSize</a></td></tr>
<tr class="memdesc:a5c27b445b5f8a1fdec3c2cb67124a743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the buffer in bytes. Must be at least 704 bytes! <br /></td></tr>
<tr class="separator:a5c27b445b5f8a1fdec3c2cb67124a743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608889cec2e77a092ec90b2f27265ad6"><td class="memItemLeft" align="right" valign="top"><a id="a608889cec2e77a092ec90b2f27265ad6"></a>
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_retained.html#a608889cec2e77a092ec90b2f27265ad6">nextFree</a> = NULL</td></tr>
<tr class="memdesc:a608889cec2e77a092ec90b2f27265ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer into the retained buffer for the next free space (where the next queued publish will be stored) <br /></td></tr>
<tr class="separator:a608889cec2e77a092ec90b2f27265ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_publish_queue_async_base"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_publish_queue_async_base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_publish_queue_async_base.html">PublishQueueAsyncBase</a></td></tr>
<tr class="memitem:a72689e01ab54e418c06bcd110b042bc6 inherit pro_attribs_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="a72689e01ab54e418c06bcd110b042bc6"></a>
Thread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a72689e01ab54e418c06bcd110b042bc6">thread</a> = NULL</td></tr>
<tr class="memdesc:a72689e01ab54e418c06bcd110b042bc6 inherit pro_attribs_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread object, created in <a class="el" href="class_publish_queue_async_base.html#a1aa68c33946bf13ed4d9c15ed7e471d4" title="Start the thread. You must call this from setup. ">setup()</a> <br /></td></tr>
<tr class="separator:a72689e01ab54e418c06bcd110b042bc6 inherit pro_attribs_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f9981e0546e787ca6efc0253d36050 inherit pro_attribs_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="a00f9981e0546e787ca6efc0253d36050"></a>
os_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a00f9981e0546e787ca6efc0253d36050">mutex</a></td></tr>
<tr class="memdesc:a00f9981e0546e787ca6efc0253d36050 inherit pro_attribs_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex to protect against concurrent access, created in <a class="el" href="class_publish_queue_async_base.html#a1aa68c33946bf13ed4d9c15ed7e471d4" title="Start the thread. You must call this from setup. ">setup()</a> <br /></td></tr>
<tr class="separator:a00f9981e0546e787ca6efc0253d36050 inherit pro_attribs_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325d1178a41cd127817ccd642e36e4f0 inherit pro_attribs_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a325d1178a41cd127817ccd642e36e4f0">failureRetryMs</a> = 30000</td></tr>
<tr class="memdesc:a325d1178a41cd127817ccd642e36e4f0 inherit pro_attribs_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default time to wait before trying to publish again after failure.  <a href="class_publish_queue_async_base.html#a325d1178a41cd127817ccd642e36e4f0">More...</a><br /></td></tr>
<tr class="separator:a325d1178a41cd127817ccd642e36e4f0 inherit pro_attribs_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d1c3bfb3f31f4149f6f77240b7b805 inherit pro_attribs_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="class_publish_queue_async_base.html">PublishQueueAsyncBase</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a84d1c3bfb3f31f4149f6f77240b7b805">stateHandler</a> = &amp;<a class="el" href="class_publish_queue_async_base.html#a4453a1e7c146338c3a7adaf66f47e379">PublishQueueAsyncBase::startState</a></td></tr>
<tr class="memdesc:a84d1c3bfb3f31f4149f6f77240b7b805 inherit pro_attribs_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">State handler function pointer.  <a href="class_publish_queue_async_base.html#a84d1c3bfb3f31f4149f6f77240b7b805">More...</a><br /></td></tr>
<tr class="separator:a84d1c3bfb3f31f4149f6f77240b7b805 inherit pro_attribs_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac136d0f2dd73551add270db06414ef18 inherit pro_attribs_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="ac136d0f2dd73551add270db06414ef18"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#ac136d0f2dd73551add270db06414ef18">stateTime</a> = 0</td></tr>
<tr class="memdesc:ac136d0f2dd73551add270db06414ef18 inherit pro_attribs_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last millis value for certain state changes like waitRetryState. <br /></td></tr>
<tr class="separator:ac136d0f2dd73551add270db06414ef18 inherit pro_attribs_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ad0d79d7740865ddbc5a257937e405 inherit pro_attribs_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="a25ad0d79d7740865ddbc5a257937e405"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a25ad0d79d7740865ddbc5a257937e405">lastPublish</a> = 0</td></tr>
<tr class="memdesc:a25ad0d79d7740865ddbc5a257937e405 inherit pro_attribs_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">milis() value for the last publish, used to control the frequency of publishes <br /></td></tr>
<tr class="separator:a25ad0d79d7740865ddbc5a257937e405 inherit pro_attribs_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7d6c7aa1915d65af7670f4bcdf1445 inherit pro_attribs_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a0c7d6c7aa1915d65af7670f4bcdf1445">isSending</a> = false</td></tr>
<tr class="memdesc:a0c7d6c7aa1915d65af7670f4bcdf1445 inherit pro_attribs_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if we're currently publishing  <a href="class_publish_queue_async_base.html#a0c7d6c7aa1915d65af7670f4bcdf1445">More...</a><br /></td></tr>
<tr class="separator:a0c7d6c7aa1915d65af7670f4bcdf1445 inherit pro_attribs_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2223328a03338c3f8ef59dbbdb2e8fab inherit pro_attribs_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a2223328a03338c3f8ef59dbbdb2e8fab">haveSetup</a> = false</td></tr>
<tr class="memdesc:a2223328a03338c3f8ef59dbbdb2e8fab inherit pro_attribs_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if <a class="el" href="class_publish_queue_async_base.html#a1aa68c33946bf13ed4d9c15ed7e471d4" title="Start the thread. You must call this from setup. ">setup()</a> has been called.  <a href="class_publish_queue_async_base.html#a2223328a03338c3f8ef59dbbdb2e8fab">More...</a><br /></td></tr>
<tr class="separator:a2223328a03338c3f8ef59dbbdb2e8fab inherit pro_attribs_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f0e2c9b8a50fa156161ca567e29abd inherit pro_attribs_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="ae8f0e2c9b8a50fa156161ca567e29abd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#ae8f0e2c9b8a50fa156161ca567e29abd">pausePublishing</a> = false</td></tr>
<tr class="memdesc:ae8f0e2c9b8a50fa156161ca567e29abd inherit pro_attribs_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if publishing has been manually paused. <br /></td></tr>
<tr class="separator:ae8f0e2c9b8a50fa156161ca567e29abd inherit pro_attribs_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_class_publish_queue_async_base"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_class_publish_queue_async_base')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="class_publish_queue_async_base.html">PublishQueueAsyncBase</a></td></tr>
<tr class="memitem:a82da94a25de2e3d51fca16f41082c5ff inherit pub_static_attribs_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a82da94a25de2e3d51fca16f41082c5ff">EVENT_BUF_SIZE</a> = sizeof(<a class="el" href="struct_publish_queue_event_data.html">PublishQueueEventData</a>) + 65 + 623</td></tr>
<tr class="memdesc:a82da94a25de2e3d51fca16f41082c5ff inherit pub_static_attribs_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of <a class="el" href="struct_publish_queue_event_data.html" title="Event data structure. ">PublishQueueEventData</a> with strings (696 bytes)  <a href="class_publish_queue_async_base.html#a82da94a25de2e3d51fca16f41082c5ff">More...</a><br /></td></tr>
<tr class="separator:a82da94a25de2e3d51fca16f41082c5ff inherit pub_static_attribs_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_publish_queue_async_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_publish_queue_async_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_publish_queue_async_base.html">PublishQueueAsyncBase</a></td></tr>
<tr class="memitem:a7763faadc5d19fd82ea917a40d8eea35 inherit pro_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="a7763faadc5d19fd82ea917a40d8eea35"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a7763faadc5d19fd82ea917a40d8eea35">threadFunction</a> ()</td></tr>
<tr class="memdesc:a7763faadc5d19fd82ea917a40d8eea35 inherit pro_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The thread function for the publish thread. <br /></td></tr>
<tr class="separator:a7763faadc5d19fd82ea917a40d8eea35 inherit pro_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4453a1e7c146338c3a7adaf66f47e379 inherit pro_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="a4453a1e7c146338c3a7adaf66f47e379"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a4453a1e7c146338c3a7adaf66f47e379">startState</a> ()</td></tr>
<tr class="memdesc:a4453a1e7c146338c3a7adaf66f47e379 inherit pro_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker thread state machine start handler. <br /></td></tr>
<tr class="separator:a4453a1e7c146338c3a7adaf66f47e379 inherit pro_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c12f03f12cd437e1406f868b6a3158 inherit pro_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="a36c12f03f12cd437e1406f868b6a3158"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a36c12f03f12cd437e1406f868b6a3158">checkQueueState</a> ()</td></tr>
<tr class="memdesc:a36c12f03f12cd437e1406f868b6a3158 inherit pro_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker thread state machine check queue state handler. <br /></td></tr>
<tr class="separator:a36c12f03f12cd437e1406f868b6a3158 inherit pro_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd57e900a77d9250228d852fba06c26 inherit pro_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="a4dd57e900a77d9250228d852fba06c26"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a4dd57e900a77d9250228d852fba06c26">waitRetryState</a> ()</td></tr>
<tr class="memdesc:a4dd57e900a77d9250228d852fba06c26 inherit pro_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker thread state machine wait to retry publishing state handler. <br /></td></tr>
<tr class="separator:a4dd57e900a77d9250228d852fba06c26 inherit pro_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_class_publish_queue_async_base"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_class_publish_queue_async_base')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="class_publish_queue_async_base.html">PublishQueueAsyncBase</a></td></tr>
<tr class="memitem:a38f573ef4ae69b3e38a82bd3036d3e7a inherit pro_static_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="a38f573ef4ae69b3e38a82bd3036d3e7a"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a38f573ef4ae69b3e38a82bd3036d3e7a">threadFunctionStatic</a> (void *param)</td></tr>
<tr class="memdesc:a38f573ef4ae69b3e38a82bd3036d3e7a inherit pro_static_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static version of the thread function. <br /></td></tr>
<tr class="separator:a38f573ef4ae69b3e38a82bd3036d3e7a inherit pro_static_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class to store the publish queue in retained memory. </p>
<p>Also works for regular RAM, though it won't survive a reset or SLEEP_MODE_DEEP. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aea133e2e65b810832aa4dcddb9f16542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea133e2e65b810832aa4dcddb9f16542">&#9670;&nbsp;</a></span>PublishQueueAsyncRetained()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PublishQueueAsyncRetained::PublishQueueAsyncRetained </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>retainedBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>retainedBufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a publish queue. </p>
<p>You normally allocate one of these as a global object. You should not create more than one, as the rate limiting would not work right.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">retainedBuffer</td><td>Pointer to the buffer in retained or regular memory</td></tr>
    <tr><td class="paramname">retainedBufferSize</td><td>Buffer size. Must be at least 704 bytes, but it's best for it to be at least 1024 bytes, and ideally larger than that. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af43b9eb856d90539ff5caacd3fbe46e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af43b9eb856d90539ff5caacd3fbe46e0">&#9670;&nbsp;</a></span>clearEvents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PublishQueueAsyncRetained::clearEvents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove any saved events. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the operation succeeded, or false if an event is currently being sent so the events cannot be deleted. </dd></dl>

<p>Implements <a class="el" href="class_publish_queue_async_base.html#ac9b8f93f878db4c2dfce2ab17ec4bf05">PublishQueueAsyncBase</a>.</p>

</div>
</div>
<a id="a86d93482fd77f1cf4a33f0d7494b406b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d93482fd77f1cf4a33f0d7494b406b">&#9670;&nbsp;</a></span>discardOldEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PublishQueueAsyncRetained::discardOldEvent </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>secondEvent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discards the oldest event or second oldest event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">secondEvent</td><td>True to discard the second oldest event</td></tr>
  </table>
  </dd>
</dl>
<p>When using retained memory, the <a class="el" href="class_publish_queue_async_retained.html#a6b5db84095bf507fc93de724e434105f" title="Get the oldest event that hasn&#39;t been published yet. ">getOldestEvent()</a> function returns a pointer to retained memory. This pointer must remain valid while in the process of publishing. If the retained buffer is full, we want to discard and old event to make room for a newer event, but we can't dispose of the oldest event, because it may be in use, so we pass true for secondEvent. </p>

<p>Implements <a class="el" href="class_publish_queue_async_base.html#a4ff4ebefebf8f89c41b3e13641c2a2b5">PublishQueueAsyncBase</a>.</p>

</div>
</div>
<a id="a6b5db84095bf507fc93de724e434105f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b5db84095bf507fc93de724e434105f">&#9670;&nbsp;</a></span>getOldestEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_publish_queue_event_data.html">PublishQueueEventData</a> * PublishQueueAsyncRetained::getOldestEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the oldest event that hasn't been published yet. </p>
<p>Returns a pointer to a <a class="el" href="struct_publish_queue_event_data.html" title="Event data structure. ">PublishQueueEventData</a> structure. This will remain valid until <a class="el" href="class_publish_queue_async_retained.html#a6b5db84095bf507fc93de724e434105f" title="Get the oldest event that hasn&#39;t been published yet. ">getOldestEvent()</a> is called again. </p>

<p>Implements <a class="el" href="class_publish_queue_async_base.html#a010258715d59b28c1352ff56d9ccf495">PublishQueueAsyncBase</a>.</p>

</div>
</div>
<a id="a094ca07795be1f7a5c694090d5c294db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a094ca07795be1f7a5c694090d5c294db">&#9670;&nbsp;</a></span>publishCommon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PublishQueueAsyncRetained::publishCommon </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eventName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ttl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublishFlags&#160;</td>
          <td class="paramname"><em>flags1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublishFlags&#160;</td>
          <td class="paramname"><em>flags2</em> = <code>PublishFlags()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish an event. All other overloads lead here. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventName</td><td>The name of the event (63 character maximum).</td></tr>
    <tr><td class="paramname">data</td><td>The event data (255 bytes maximum, 622 bytes in system firmware 0.8.0-rc.4 and later).</td></tr>
    <tr><td class="paramname">ttl</td><td>The time-to-live value. If not specified in one of the other overloads, the value 60 is used. However, the ttl is ignored by the cloud, so it doesn't matter what you set it to. Essentially all events are discarded immediately if not subscribed to so they essentially have a ttl of 0.</td></tr>
    <tr><td class="paramname">flags1</td><td>Normally PRIVATE. You can also use PUBLIC, but one or the other must be specified.</td></tr>
    <tr><td class="paramname">flags2</td><td>(optional) You can use NO_ACK or WITH_ACK if desired.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the event was queued or false if it was not.</dd></dl>
<p>This function almost always returns true. If you queue more events than fit in the buffer the oldest (sometimes second oldest) is discarded. </p>

<p>Implements <a class="el" href="class_publish_queue_async_base.html#a9fd5556a87ef87adacb215f7b9ae03af">PublishQueueAsyncBase</a>.</p>

</div>
</div>
<a id="a49fe10a9710aeffee1f0e80b8d71a548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49fe10a9710aeffee1f0e80b8d71a548">&#9670;&nbsp;</a></span>skipEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * PublishQueueAsyncRetained::skipEvent </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a pointer into the retained buffer, finds the offset of the next event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Where to start (pointer to RAM, not an offset)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the beginning of the next event </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_publish_queue_async_r_k_8h_source.html">PublishQueueAsyncRK.h</a></li>
<li>src/PublishQueueAsyncRK.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
