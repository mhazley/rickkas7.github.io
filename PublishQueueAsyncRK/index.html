<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PublishQueueAsyncRK: PublishQueueAsyncRK</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PublishQueueAsyncRK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">PublishQueueAsyncRK </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><em>A library for asynchronous Particle.publish</em></p>
<p>This library is designed for fire-and-forget publishing of events. It allows you to publish, even when not connected to the cloud, and the events are saved until connected. It also buffers events so you can call it a bunch of times rapidly and the events are metered out one per second to stay within the publish limits.</p>
<p>Also, it's entirely non-blocking. The publishing occurs from a separate thread so the loop is never blocked.</p>
<p>Normally, if you're careful you can avoid publish blocking loop for long periods of time, but it still regularly blocks for 1-2 seconds on the Electron. Using this library eliminates all blocking and publishQueue.publish returns immediately, always.</p>
<p>And it uses retained memory, so the events are saved when you reboot or go into sleep mode. They'll be transmitted when you finally connect to the cloud again.</p>
<p>Version 0.0.3 of this library and newer support WITH_ACK mode!</p>
<p>Also note: This library requires system firmware 0.7.0 or later. The publish flags were different in 0.6.x, and this library doesn't support the old method. Since it uses threads, it does not work on the Spark Core.</p>
<p>Version 0.1.0 supports multiple back-end storage methods, including:</p>
<ul>
<li>Retained memory</li>
<li>FRAM (MB85RC256V ferro-electric non-volatile RAM) connected by I2C</li>
<li>SPI Flash (using SpiffsParticleRK)</li>
<li>SPI Flash memory on P1 module</li>
<li>External SPI Flash soldered to E Series module</li>
<li>SD cards using the SdFat library</li>
</ul>
<h2>Using it</h2>
<p>You'll need to add the PublishQueueAsyncRK library. It's in the community libraries and here on Github.</p>
<p>In your main source file, you'll need to allocate a retained buffer and initialize the object:</p>
<div class="fragment"><div class="line">retained uint8_t publishQueueRetainedBuffer[2048];</div><div class="line">PublishQueueAsync publishQueue(publishQueueRetainedBuffer, sizeof(publishQueueRetainedBuffer));</div></div><!-- fragment --><p>Note that even when cloud connected, all events are copied to this buffer first (that's what makes it asynchronous), so it must be larger than the largest event you want to send. It must be at least 704 bytes, and preferably at least 1024 bytes.</p>
<p>You can also use a buffer in regular (not retained) memory.</p>
<p>For other storage methods (FRAM, flash memory, etc. see below). The initialization varies, but usage is the same.</p>
<p>Then, when you want to send, use one of these variants instead of the Particle.publish version:</p>
<div class="fragment"><div class="line">publishQueue.publish(&quot;testEvent&quot;, PRIVATE, WITH_ACK);</div><div class="line">publishQueue.publish(&quot;testEvent&quot;, &quot;x&quot;, PRIVATE, WITH_ACK);</div><div class="line">publishQueue.publish(&quot;testEvent&quot;, &quot;x&quot;, 60, PRIVATE, WITH_ACK);</div></div><!-- fragment --><p>Note that like system 0.8.0 and later, you must specify PUBLIC or PRIVATE.</p>
<p>You can also use NO_ACK, if you'd like:</p>
<div class="fragment"><div class="line">publishQueue.publish(&quot;testEvent&quot;, &quot;x&quot;, PRIVATE, NO_ACK);</div><div class="line">publishQueue.publish(&quot;testEvent&quot;, &quot;x&quot;, PRIVATE | NO_ACK);</div></div><!-- fragment --><p>I recommend using WITH_ACK. The worker thread will wait for the ACK from the cloud before dequeing the event. This allows for several tries to send the event, and if it does not work, the send will be tried again in 30 seconds if cloud-connected. New events can still be queued during this time.</p>
<p>Since the queue is stored in retained memory, you can even reset the device and the queue will be transmitted on boot.</p>
<p>You can call the publishQueue.publish method from any thread, including the main loop thread, software timer, or your own worker thread. You cannot call it from an interrupt service routine (ISR) such as from attachInterrupt or a hardware timer (SparkIntervalTimer), however.</p>
<p>The data is stored packed, so if your event name and data are small, you can store many events. From the retained buffer you pass in there is 8 bytes of overhead. Then each event requires the size of the event name and event data in bytes, plus an overhead of 10 bytes (8 byte header and 2 c-string null terminators), rounded up to a multiple of 4 bytes so each entry starts on a 4-byte aligned boundary.</p>
<p>The library is also compatible with 622 byte event data <a href="https://github.com/particle-iot/firmware/pull/1537">in 0.8.0-rc.4 and later</a>).</p>
<p>Events are logged with the category app.pubq so you can use a <a href="https://docs.particle.io/reference/firmware/#logging-categories">logging filter</a> to disable them if desired.</p>
<div class="fragment"><div class="line">0000210062 [app.pubq] INFO: queueing eventName=testEvent data=7 ttl=60 flags1=1 flags2=0 size=20</div><div class="line">0000210063 [app.pubq] INFO: publishing testEvent 7 ttl=60 flags=1</div><div class="line">0000211105 [app.pubq] INFO: published successfully</div></div><!-- fragment --><h2>Examples</h2>
<p>There are three examples:</p>
<ul>
<li>1-periodic</li>
<li>2-button-and-timer</li>
<li>3-test-suite</li>
</ul>
<p>The first one publishes every 30 seconds from loop using a millis() check. It uses WITH_ACK.</p>
<p>The second one publishes every 30 seconds from a software timer. It also publishes when you press the MODE button. It uses WITH_ACK.</p>
<p>The third is described in the next section.</p>
<h2>More Examples</h2>
<p>There are examples of using other storage methods in the more-examples directory.</p>
<h3>MB85RC256V FRAM</h3>
<p>You typically include something like this at the top of your main source file. The order is important; you must include the FRAM include file before <a class="el" href="_publish_queue_async_r_k_8h_source.html">PublishQueueAsyncRK.h</a> in order to enable FRAM support.</p>
<div class="fragment"><div class="line">#include &quot;MB85RC256V-FRAM-RK.h&quot;</div><div class="line">#include &quot;PublishQueueAsyncRK.h&quot;</div><div class="line"></div><div class="line">MB85RC256V fram(Wire, 0);</div><div class="line"></div><div class="line">PublishQueueAsyncFRAM publishQueue(fram);</div></div><!-- fragment --><p>In setup(), be sure to initialize the FRAM library and then the publishQueue, in that order.</p>
<div class="fragment"><div class="line">fram.begin();</div><div class="line">publishQueue.setup();</div></div><!-- fragment --><p>If you only want to use a subset of the FRAM for the publish queue, specify an offset and length in the constructor</p>
<div class="fragment"><div class="line">PublishQueueAsyncFRAM publishQueue(fram, 100, 2000);</div></div><!-- fragment --><h3>SPI Flash using SpiffsParticleRK</h3>
<p>Using SpiffsParticleRK you can store events in a variety of SPI NOR flash memory chips using the SpiFlashRK library.</p>
<p>You typically include something like this at the top of your main source file. The order is important; you must include the SdFat.h before <a class="el" href="_publish_queue_async_r_k_8h_source.html">PublishQueueAsyncRK.h</a> in order to enable SD card support.</p>
<p>The second parameter to the publish queue constructor is the filename, it should be an 8.3 filename. It will contain binary data.</p>
<div class="fragment"><div class="line">#include &quot;SpiffsParticleRK.h&quot;</div><div class="line">#include &quot;PublishQueueAsyncRK.h&quot;</div><div class="line"></div><div class="line">SpiFlashISSI spiFlash(SPI, A2);         // ISSI flash on SPI (A pins)</div><div class="line"></div><div class="line">SpiffsParticle fs(spiFlash);</div><div class="line"></div><div class="line">PublishQueueAsyncSpiffs publishQueue(fs, &quot;events&quot;);</div></div><!-- fragment --><p>In setup(), you initialize it like this:</p>
<div class="fragment"><div class="line">spiFlash.begin();</div><div class="line"></div><div class="line">// Dedicate 64 Kbytes to file system (increase as desired)</div><div class="line">fs.withPhysicalSize(64 * 1024);</div><div class="line"></div><div class="line">s32_t res = fs.mountAndFormatIfNecessary();</div><div class="line">Log.info(&quot;mount res=%ld&quot;, res);</div><div class="line">if (res == 0) {</div><div class="line">    publishQueue.setup();</div><div class="line">}</div></div><!-- fragment --><h4>Instantiating a SpiFlash object</h4>
<p>You typically instantiate an object to interface to the flash chip as a global variable:</p>
<div class="fragment"><div class="line">SpiFlashISSI spiFlash(SPI, A2);</div></div><!-- fragment --><p>Use an ISSI flash, such as a <a href="http://www.digikey.com/product-detail/en/issi-integrated-silicon-solution-inc/IS25LQ080B-JNLE/706-1331-ND/5189766">IS25LQ080B</a>. In this case, connected to the primary SPI with A2 as the CS (chip select or SS).</p>
<div class="fragment"><div class="line">SpiFlashWinbond spiFlash(SPI, A2);</div></div><!-- fragment --><p>Use a Winbond flash, such as a <a href="https://www.digikey.com/product-detail/en/winbond-electronics/W25Q32JVSSIQ/W25Q32JVSSIQ-ND/5803981">W25Q32</a>. In this case, connected to the primary SPI with A2 as the CS (chip select or SS).</p>
<div class="fragment"><div class="line">SpiFlashWinbond spiFlash(SPI1, D5);</div></div><!-- fragment --><p>Winbond flash, connected to the secondary SPI, SPI1, with D5 as the CS (chip select or SS).</p>
<div class="fragment"><div class="line">SpiFlashMacronix spiFlash(SPI1, D5);</div></div><!-- fragment --><p>Macronix flash, such as the <a href="https://www.digikey.com/product-detail/en/macronix/MX25L8006EM1I-12G/1092-1117-ND/2744800">MX25L8006EM1I-12G</a>. In this case connected to the secondary SPI, SPI1, with D5 as the CS (chip select or SS). This is the recommended for use on the E-Series module. Note that this is the 0.154", 3.90mm width 8-SOIC package.</p>
<div class="fragment"><div class="line">SpiFlashP1 spiFlash;</div></div><!-- fragment --><p>This is the external flash on the P1 module. This extra flash chip is entirely available for your user; it is not used by the system firmware at this time. You can only use this on the P1; it relies on system functions that are not available on other devices.</p>
<h3>SD cards using SdFat</h3>
<p>You typically include something like this at the top of your main source file. The order is important; you must include the SdFat.h before <a class="el" href="_publish_queue_async_r_k_8h_source.html">PublishQueueAsyncRK.h</a> in order to enable SD card support.</p>
<p>The second parameter to the publish queue constructor is the filename, it should be an 8.3 filename. It will contain binary data.</p>
<div class="fragment"><div class="line">#include &quot;SdFat.h&quot;</div><div class="line">#include &quot;PublishQueueAsyncRK.h&quot;</div><div class="line"></div><div class="line">const int SD_CHIP_SELECT = A2;</div><div class="line"></div><div class="line">SdFat sdCard;</div><div class="line"></div><div class="line">PublishQueueAsyncSdFat publishQueue(sdCard, &quot;events.dat&quot;);</div></div><!-- fragment --><p>In your setup function you typically call:</p>
<div class="fragment"><div class="line">if (sdCard.begin(SD_CHIP_SELECT, SPI_FULL_SPEED)) {</div><div class="line">    publishQueue.setup();</div><div class="line">}</div><div class="line">else {</div><div class="line">    Log.info(&quot;failed to initialize sd card&quot;);</div><div class="line">}</div></div><!-- fragment --><h2>Test Suite</h2>
<p>The example 03-test-suite makes it easy to test some of the features. Flag the code to a Photon or Electron and send a function to it to make it do things:</p>
<p>The first parameter is the test number:</p>
<ul>
<li>0 idle</li>
<li>1 publish periodically</li>
<li>2 publish rapidly</li>
<li>3 disconnect from the cloud, publish rapidly, then reconnect</li>
<li>4 publish periodically using WITH_ACK</li>
</ul>
<p>There may be additional parameters based on the test number, as well. </p><hr/>
<div class="fragment"><div class="line">particle call electron3 test &quot;1,10000&quot;</div></div><!-- fragment --><p>Publish a sequential event every 10 seconds. </p><hr/>
<div class="fragment"><div class="line">particle call electron3 test &quot;0&quot;</div></div><!-- fragment --><p>Stop publish events </p><hr/>
<div class="fragment"><div class="line">particle call electron3 test &quot;2,5,64&quot;</div></div><!-- fragment --><p>Publish 5 events of 64 bytes each. </p><hr/>
<div class="fragment"><div class="line">particle call electron3 test &quot;3,5,64&quot;</div></div><!-- fragment --><p>Disconnect from the cloud, publish 5 events of 64 bytes each, then go back online.</p>
<h2>Version History</h2>
<h3>0.1.0 (2019-10-30)</h3>
<ul>
<li>Refactored code to allow for storage in other things like FRAM, SPI Flash, and SD Card.</li>
</ul>
<h3>0.0.5 (2019-06-27)</h3>
<ul>
<li>Same code as 0.0.4 but corrected the comments that said that WITH_ACK was not supported.</li>
</ul>
<h3>0.0.4 (2019-06-12)</h3>
<ul>
<li>Fixed a cause where deadlock can occur if the queue fills up. If another thread was logging when this occurred, the Log.trace in the publish queue thread will block on the logging mutex, but the mutex can never clear because of the SINGLE_THREADED_BLOCK.</li>
</ul>
<h3>0.0.3</h3>
<ul>
<li>Added support for WITH_ACK mode</li>
</ul>
<h3>0.1.0</h3>
<ul>
<li>Added support for other storage methods </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
