<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PublishQueueAsyncRK: PublishQueueAsyncFileSystem Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PublishQueueAsyncRK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">PublishQueueAsyncFileSystem Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstract class for file system-based events storage (SPIFFS, SdCard, etc.)  
 <a href="class_publish_queue_async_file_system.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_publish_queue_async_r_k_8h_source.html">PublishQueueAsyncRK.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PublishQueueAsyncFileSystem:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_publish_queue_async_file_system.png" usemap="#PublishQueueAsyncFileSystem_map" alt=""/>
  <map id="PublishQueueAsyncFileSystem_map" name="PublishQueueAsyncFileSystem_map">
<area href="class_publish_queue_async_file_system_base.html" title="Abstract base class for file system-based storage. " alt="PublishQueueAsyncFileSystemBase" shape="rect" coords="113,56,329,80"/>
<area href="class_publish_queue_async_base.html" title="Abstract base class for async publish queue. " alt="PublishQueueAsyncBase" shape="rect" coords="113,0,329,24"/>
<area href="class_publish_queue_async_sd_fat.html" title="Concrete subclass for storing events on a SdFat file system. " alt="PublishQueueAsyncSdFat" shape="rect" coords="0,168,216,192"/>
<area href="class_publish_queue_async_spiffs.html" title="Concrete subclass to store events on SPIFFS file system. " alt="PublishQueueAsyncSpiffs" shape="rect" coords="226,168,442,192"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a67eaf632945ed97445eeb73f157b0fa0"><td class="memItemLeft" align="right" valign="top"><a id="a67eaf632945ed97445eeb73f157b0fa0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_file_system.html#a67eaf632945ed97445eeb73f157b0fa0">PublishQueueAsyncFileSystem</a> ()</td></tr>
<tr class="memdesc:a67eaf632945ed97445eeb73f157b0fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class constructor. <br /></td></tr>
<tr class="separator:a67eaf632945ed97445eeb73f157b0fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36fd6555a5a853d3a8aaaa4119eed823"><td class="memItemLeft" align="right" valign="top"><a id="a36fd6555a5a853d3a8aaaa4119eed823"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_file_system.html#a36fd6555a5a853d3a8aaaa4119eed823">~PublishQueueAsyncFileSystem</a> ()</td></tr>
<tr class="memdesc:a36fd6555a5a853d3a8aaaa4119eed823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class destructor. <br /></td></tr>
<tr class="separator:a36fd6555a5a853d3a8aaaa4119eed823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a3bbe83d86fd514e70dd628564e5c0"><td class="memItemLeft" align="right" valign="top"><a id="aa6a3bbe83d86fd514e70dd628564e5c0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_file_system.html#aa6a3bbe83d86fd514e70dd628564e5c0">setup</a> ()</td></tr>
<tr class="memdesc:aa6a3bbe83d86fd514e70dd628564e5c0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_publish_queue_async_file_system.html#aa6a3bbe83d86fd514e70dd628564e5c0" title="setup() must be called from the main setup() function! ">setup()</a> must be called from the main <a class="el" href="class_publish_queue_async_file_system.html#aa6a3bbe83d86fd514e70dd628564e5c0" title="setup() must be called from the main setup() function! ">setup()</a> function! <br /></td></tr>
<tr class="separator:aa6a3bbe83d86fd514e70dd628564e5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f7751626b59b342ddafb70744885b4"><td class="memItemLeft" align="right" valign="top"><a id="a08f7751626b59b342ddafb70744885b4"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_file_system.html#a08f7751626b59b342ddafb70744885b4">publishCommon</a> (const char *eventName, const char *data, int ttl, PublishFlags flags1, PublishFlags flags2=PublishFlags())</td></tr>
<tr class="memdesc:a08f7751626b59b342ddafb70744885b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the publish data to the events file. <br /></td></tr>
<tr class="separator:a08f7751626b59b342ddafb70744885b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963b036bacbd8c64526d5c3598f85b58"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_publish_queue_event_data.html">PublishQueueEventData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_file_system.html#a963b036bacbd8c64526d5c3598f85b58">getOldestEvent</a> ()</td></tr>
<tr class="memdesc:a963b036bacbd8c64526d5c3598f85b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the oldest event that hasn't been published yet.  <a href="#a963b036bacbd8c64526d5c3598f85b58">More...</a><br /></td></tr>
<tr class="separator:a963b036bacbd8c64526d5c3598f85b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abacc860791e7f1bcc00227cd6e784ab9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_file_system.html#abacc860791e7f1bcc00227cd6e784ab9">clearEvents</a> ()</td></tr>
<tr class="memdesc:abacc860791e7f1bcc00227cd6e784ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove any saved events.  <a href="#abacc860791e7f1bcc00227cd6e784ab9">More...</a><br /></td></tr>
<tr class="separator:abacc860791e7f1bcc00227cd6e784ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc8176c701a54dc67f151abfd2f86a4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_file_system.html#aabc8176c701a54dc67f151abfd2f86a4">discardOldEvent</a> (bool secondEvent)</td></tr>
<tr class="memdesc:aabc8176c701a54dc67f151abfd2f86a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discard an event.  <a href="#aabc8176c701a54dc67f151abfd2f86a4">More...</a><br /></td></tr>
<tr class="separator:aabc8176c701a54dc67f151abfd2f86a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6bfd902d13e872c3c3197d7719b3c6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_file_system.html#aca6bfd902d13e872c3c3197d7719b3c6">skipEvent</a> (size_t addr, uint8_t *buf)</td></tr>
<tr class="memdesc:aca6bfd902d13e872c3c3197d7719b3c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip to the next event.  <a href="#aca6bfd902d13e872c3c3197d7719b3c6">More...</a><br /></td></tr>
<tr class="separator:aca6bfd902d13e872c3c3197d7719b3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_publish_queue_async_file_system_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_publish_queue_async_file_system_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_publish_queue_async_file_system_base.html">PublishQueueAsyncFileSystemBase</a></td></tr>
<tr class="memitem:ad10fcc351f74b76cbcd68830fa3302ba inherit pub_methods_class_publish_queue_async_file_system_base"><td class="memItemLeft" align="right" valign="top"><a id="ad10fcc351f74b76cbcd68830fa3302ba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_file_system_base.html#ad10fcc351f74b76cbcd68830fa3302ba">PublishQueueAsyncFileSystemBase</a> ()</td></tr>
<tr class="memdesc:ad10fcc351f74b76cbcd68830fa3302ba inherit pub_methods_class_publish_queue_async_file_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base constructor. Doesn't do anything. <br /></td></tr>
<tr class="separator:ad10fcc351f74b76cbcd68830fa3302ba inherit pub_methods_class_publish_queue_async_file_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d5b80a67dab403f325dd847403b654 inherit pub_methods_class_publish_queue_async_file_system_base"><td class="memItemLeft" align="right" valign="top"><a id="af5d5b80a67dab403f325dd847403b654"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_file_system_base.html#af5d5b80a67dab403f325dd847403b654">~PublishQueueAsyncFileSystemBase</a> ()</td></tr>
<tr class="memdesc:af5d5b80a67dab403f325dd847403b654 inherit pub_methods_class_publish_queue_async_file_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base destructor. Doesn't do anything. <br /></td></tr>
<tr class="separator:af5d5b80a67dab403f325dd847403b654 inherit pub_methods_class_publish_queue_async_file_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc3b4049e438d873beb731c2b894749 inherit pub_methods_class_publish_queue_async_file_system_base"><td class="memItemLeft" align="right" valign="top"><a id="aecc3b4049e438d873beb731c2b894749"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_file_system_base.html#aecc3b4049e438d873beb731c2b894749">openFile</a> ()=0</td></tr>
<tr class="memdesc:aecc3b4049e438d873beb731c2b894749 inherit pub_methods_class_publish_queue_async_file_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the events file. <br /></td></tr>
<tr class="separator:aecc3b4049e438d873beb731c2b894749 inherit pub_methods_class_publish_queue_async_file_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95ef6c2e88456819e45580bdf1a487a inherit pub_methods_class_publish_queue_async_file_system_base"><td class="memItemLeft" align="right" valign="top"><a id="ac95ef6c2e88456819e45580bdf1a487a"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_file_system_base.html#ac95ef6c2e88456819e45580bdf1a487a">closeFile</a> ()=0</td></tr>
<tr class="memdesc:ac95ef6c2e88456819e45580bdf1a487a inherit pub_methods_class_publish_queue_async_file_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the events file. <br /></td></tr>
<tr class="separator:ac95ef6c2e88456819e45580bdf1a487a inherit pub_methods_class_publish_queue_async_file_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5bc34ef781010b0e6f4e8312bd89c81 inherit pub_methods_class_publish_queue_async_file_system_base"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_file_system_base.html#ad5bc34ef781010b0e6f4e8312bd89c81">truncate</a> (size_t size)=0</td></tr>
<tr class="memdesc:ad5bc34ef781010b0e6f4e8312bd89c81 inherit pub_methods_class_publish_queue_async_file_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate a file to a specified length in bytes.  <a href="class_publish_queue_async_file_system_base.html#ad5bc34ef781010b0e6f4e8312bd89c81">More...</a><br /></td></tr>
<tr class="separator:ad5bc34ef781010b0e6f4e8312bd89c81 inherit pub_methods_class_publish_queue_async_file_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb5d184c1a9666f26743ce9c7fe04d8 inherit pub_methods_class_publish_queue_async_file_system_base"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_file_system_base.html#a6fb5d184c1a9666f26743ce9c7fe04d8">readBytes</a> (int seekTo, uint8_t *buffer, size_t length)=0</td></tr>
<tr class="memdesc:a6fb5d184c1a9666f26743ce9c7fe04d8 inherit pub_methods_class_publish_queue_async_file_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bytes from the file.  <a href="class_publish_queue_async_file_system_base.html#a6fb5d184c1a9666f26743ce9c7fe04d8">More...</a><br /></td></tr>
<tr class="separator:a6fb5d184c1a9666f26743ce9c7fe04d8 inherit pub_methods_class_publish_queue_async_file_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0072e34090af180dab0e5a958434eea4 inherit pub_methods_class_publish_queue_async_file_system_base"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_file_system_base.html#a0072e34090af180dab0e5a958434eea4">writeBytes</a> (int seekTo, const uint8_t *buffer, size_t length)=0</td></tr>
<tr class="memdesc:a0072e34090af180dab0e5a958434eea4 inherit pub_methods_class_publish_queue_async_file_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write bytes to the file.  <a href="class_publish_queue_async_file_system_base.html#a0072e34090af180dab0e5a958434eea4">More...</a><br /></td></tr>
<tr class="separator:a0072e34090af180dab0e5a958434eea4 inherit pub_methods_class_publish_queue_async_file_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0359a37a8d86a90ab24e76d178fc8703 inherit pub_methods_class_publish_queue_async_file_system_base"><td class="memItemLeft" align="right" valign="top"><a id="a0359a37a8d86a90ab24e76d178fc8703"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_file_system_base.html#a0359a37a8d86a90ab24e76d178fc8703">getLength</a> ()=0</td></tr>
<tr class="memdesc:a0359a37a8d86a90ab24e76d178fc8703 inherit pub_methods_class_publish_queue_async_file_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get length of the file (or a negative error code on error) <br /></td></tr>
<tr class="separator:a0359a37a8d86a90ab24e76d178fc8703 inherit pub_methods_class_publish_queue_async_file_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_publish_queue_async_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_publish_queue_async_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_publish_queue_async_base.html">PublishQueueAsyncBase</a></td></tr>
<tr class="memitem:a0f99925ab8cba714e54364adb80a2582 inherit pub_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="a0f99925ab8cba714e54364adb80a2582"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a0f99925ab8cba714e54364adb80a2582">PublishQueueAsyncBase</a> ()</td></tr>
<tr class="memdesc:a0f99925ab8cba714e54364adb80a2582 inherit pub_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a publish queue. <br /></td></tr>
<tr class="separator:a0f99925ab8cba714e54364adb80a2582 inherit pub_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29fb8c23ba93bbade9c176fce84ef9c inherit pub_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="ae29fb8c23ba93bbade9c176fce84ef9c"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#ae29fb8c23ba93bbade9c176fce84ef9c">~PublishQueueAsyncBase</a> ()</td></tr>
<tr class="memdesc:ae29fb8c23ba93bbade9c176fce84ef9c inherit pub_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">You normally allocate this as a global object and never delete it. <br /></td></tr>
<tr class="separator:ae29fb8c23ba93bbade9c176fce84ef9c inherit pub_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b6306491fc1c4993677f7a09373040 inherit pub_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#ab9b6306491fc1c4993677f7a09373040">publish</a> (const char *eventName, PublishFlags flags1, PublishFlags flags2=PublishFlags())</td></tr>
<tr class="memdesc:ab9b6306491fc1c4993677f7a09373040 inherit pub_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for publishing an event.  <a href="class_publish_queue_async_base.html#ab9b6306491fc1c4993677f7a09373040">More...</a><br /></td></tr>
<tr class="separator:ab9b6306491fc1c4993677f7a09373040 inherit pub_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd76b1db3e72968c899a6d25cda385ac inherit pub_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#abd76b1db3e72968c899a6d25cda385ac">publish</a> (const char *eventName, const char *data, PublishFlags flags1, PublishFlags flags2=PublishFlags())</td></tr>
<tr class="memdesc:abd76b1db3e72968c899a6d25cda385ac inherit pub_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for publishing an event.  <a href="class_publish_queue_async_base.html#abd76b1db3e72968c899a6d25cda385ac">More...</a><br /></td></tr>
<tr class="separator:abd76b1db3e72968c899a6d25cda385ac inherit pub_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386c05f3d4f78e8b18d52c77fcd7d03a inherit pub_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a386c05f3d4f78e8b18d52c77fcd7d03a">publish</a> (const char *eventName, const char *data, int ttl, PublishFlags flags1, PublishFlags flags2=PublishFlags())</td></tr>
<tr class="memdesc:a386c05f3d4f78e8b18d52c77fcd7d03a inherit pub_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for publishing an event.  <a href="class_publish_queue_async_base.html#a386c05f3d4f78e8b18d52c77fcd7d03a">More...</a><br /></td></tr>
<tr class="separator:a386c05f3d4f78e8b18d52c77fcd7d03a inherit pub_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293b9cbbb28c8df2ee3d4dcd631c8288 inherit pub_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_publish_queue_async_base.html">PublishQueueAsyncBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a293b9cbbb28c8df2ee3d4dcd631c8288">withFailureRetryMs</a> (unsigned long value)</td></tr>
<tr class="memdesc:a293b9cbbb28c8df2ee3d4dcd631c8288 inherit pub_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the retry after publish failure time.  <a href="class_publish_queue_async_base.html#a293b9cbbb28c8df2ee3d4dcd631c8288">More...</a><br /></td></tr>
<tr class="separator:a293b9cbbb28c8df2ee3d4dcd631c8288 inherit pub_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70c0a7eada8a75ea376b134baf66dd0 inherit pub_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#aa70c0a7eada8a75ea376b134baf66dd0">setPausePublishing</a> (bool pause)</td></tr>
<tr class="memdesc:aa70c0a7eada8a75ea376b134baf66dd0 inherit pub_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause publishing, even if it would be allowed because the cloud is connected.  <a href="class_publish_queue_async_base.html#aa70c0a7eada8a75ea376b134baf66dd0">More...</a><br /></td></tr>
<tr class="separator:aa70c0a7eada8a75ea376b134baf66dd0 inherit pub_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8da81748f9fdb1925254a67126f465e inherit pub_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#ab8da81748f9fdb1925254a67126f465e">getPausePublishing</a> () const</td></tr>
<tr class="memdesc:ab8da81748f9fdb1925254a67126f465e inherit pub_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if publishing is manually paused.  <a href="class_publish_queue_async_base.html#ab8da81748f9fdb1925254a67126f465e">More...</a><br /></td></tr>
<tr class="separator:ab8da81748f9fdb1925254a67126f465e inherit pub_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4e10fcf529d6d477cda3a2abb0a2ff inherit pub_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a4e4e10fcf529d6d477cda3a2abb0a2ff">mutexLock</a> () const</td></tr>
<tr class="memdesc:a4e4e10fcf529d6d477cda3a2abb0a2ff inherit pub_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a mutex lock.  <a href="class_publish_queue_async_base.html#a4e4e10fcf529d6d477cda3a2abb0a2ff">More...</a><br /></td></tr>
<tr class="separator:a4e4e10fcf529d6d477cda3a2abb0a2ff inherit pub_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3410502e46602fe26aa2fe372663119 inherit pub_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="af3410502e46602fe26aa2fe372663119"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#af3410502e46602fe26aa2fe372663119">mutexUnlock</a> () const</td></tr>
<tr class="memdesc:af3410502e46602fe26aa2fe372663119 inherit pub_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the mutex. <br /></td></tr>
<tr class="separator:af3410502e46602fe26aa2fe372663119 inherit pub_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a8ce6d33119f4aec9944f37c0563efd05"><td class="memItemLeft" align="right" valign="top"><a id="a8ce6d33119f4aec9944f37c0563efd05"></a>
<a class="el" href="struct_publish_queue_header.html">PublishQueueHeader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_file_system.html#a8ce6d33119f4aec9944f37c0563efd05">header</a></td></tr>
<tr class="memdesc:a8ce6d33119f4aec9944f37c0563efd05"><td class="mdescLeft">&#160;</td><td class="mdescRight">The header, copied from the file system. <br /></td></tr>
<tr class="separator:a8ce6d33119f4aec9944f37c0563efd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f26c564e5d9fb314f7b9c92560fc701"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_file_system.html#a4f26c564e5d9fb314f7b9c92560fc701">eventBuf</a> [<a class="el" href="class_publish_queue_async_base.html#a82da94a25de2e3d51fca16f41082c5ff">EVENT_BUF_SIZE</a>]</td></tr>
<tr class="memdesc:a4f26c564e5d9fb314f7b9c92560fc701"><td class="mdescLeft">&#160;</td><td class="mdescRight">This holds a single event during scanning and writing.  <a href="#a4f26c564e5d9fb314f7b9c92560fc701">More...</a><br /></td></tr>
<tr class="separator:a4f26c564e5d9fb314f7b9c92560fc701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a6fadd941589e88baf418733d6425a"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_file_system.html#ad0a6fadd941589e88baf418733d6425a">publishBuf</a> [<a class="el" href="class_publish_queue_async_base.html#a82da94a25de2e3d51fca16f41082c5ff">EVENT_BUF_SIZE</a>]</td></tr>
<tr class="memdesc:ad0a6fadd941589e88baf418733d6425a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This holds a single event during publish.  <a href="#ad0a6fadd941589e88baf418733d6425a">More...</a><br /></td></tr>
<tr class="separator:ad0a6fadd941589e88baf418733d6425a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a93e1375556314518bf478245030a8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_file_system.html#ac7a93e1375556314518bf478245030a8">oldestPos</a> = 0</td></tr>
<tr class="memdesc:ac7a93e1375556314518bf478245030a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset in the file for the oldest event. We begin publishing at this offset.  <a href="#ac7a93e1375556314518bf478245030a8">More...</a><br /></td></tr>
<tr class="separator:ac7a93e1375556314518bf478245030a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_publish_queue_async_base"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_publish_queue_async_base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_publish_queue_async_base.html">PublishQueueAsyncBase</a></td></tr>
<tr class="memitem:a72689e01ab54e418c06bcd110b042bc6 inherit pro_attribs_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="a72689e01ab54e418c06bcd110b042bc6"></a>
Thread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a72689e01ab54e418c06bcd110b042bc6">thread</a> = NULL</td></tr>
<tr class="memdesc:a72689e01ab54e418c06bcd110b042bc6 inherit pro_attribs_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread object, created in <a class="el" href="class_publish_queue_async_base.html#a1aa68c33946bf13ed4d9c15ed7e471d4" title="Start the thread. You must call this from setup. ">setup()</a> <br /></td></tr>
<tr class="separator:a72689e01ab54e418c06bcd110b042bc6 inherit pro_attribs_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f9981e0546e787ca6efc0253d36050 inherit pro_attribs_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="a00f9981e0546e787ca6efc0253d36050"></a>
os_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a00f9981e0546e787ca6efc0253d36050">mutex</a></td></tr>
<tr class="memdesc:a00f9981e0546e787ca6efc0253d36050 inherit pro_attribs_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex to protect against concurrent access, created in <a class="el" href="class_publish_queue_async_base.html#a1aa68c33946bf13ed4d9c15ed7e471d4" title="Start the thread. You must call this from setup. ">setup()</a> <br /></td></tr>
<tr class="separator:a00f9981e0546e787ca6efc0253d36050 inherit pro_attribs_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325d1178a41cd127817ccd642e36e4f0 inherit pro_attribs_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a325d1178a41cd127817ccd642e36e4f0">failureRetryMs</a> = 30000</td></tr>
<tr class="memdesc:a325d1178a41cd127817ccd642e36e4f0 inherit pro_attribs_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default time to wait before trying to publish again after failure.  <a href="class_publish_queue_async_base.html#a325d1178a41cd127817ccd642e36e4f0">More...</a><br /></td></tr>
<tr class="separator:a325d1178a41cd127817ccd642e36e4f0 inherit pro_attribs_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d1c3bfb3f31f4149f6f77240b7b805 inherit pro_attribs_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="class_publish_queue_async_base.html">PublishQueueAsyncBase</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a84d1c3bfb3f31f4149f6f77240b7b805">stateHandler</a> = &amp;<a class="el" href="class_publish_queue_async_base.html#a4453a1e7c146338c3a7adaf66f47e379">PublishQueueAsyncBase::startState</a></td></tr>
<tr class="memdesc:a84d1c3bfb3f31f4149f6f77240b7b805 inherit pro_attribs_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">State handler function pointer.  <a href="class_publish_queue_async_base.html#a84d1c3bfb3f31f4149f6f77240b7b805">More...</a><br /></td></tr>
<tr class="separator:a84d1c3bfb3f31f4149f6f77240b7b805 inherit pro_attribs_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac136d0f2dd73551add270db06414ef18 inherit pro_attribs_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="ac136d0f2dd73551add270db06414ef18"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#ac136d0f2dd73551add270db06414ef18">stateTime</a> = 0</td></tr>
<tr class="memdesc:ac136d0f2dd73551add270db06414ef18 inherit pro_attribs_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last millis value for certain state changes like waitRetryState. <br /></td></tr>
<tr class="separator:ac136d0f2dd73551add270db06414ef18 inherit pro_attribs_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ad0d79d7740865ddbc5a257937e405 inherit pro_attribs_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="a25ad0d79d7740865ddbc5a257937e405"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a25ad0d79d7740865ddbc5a257937e405">lastPublish</a> = 0</td></tr>
<tr class="memdesc:a25ad0d79d7740865ddbc5a257937e405 inherit pro_attribs_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">milis() value for the last publish, used to control the frequency of publishes <br /></td></tr>
<tr class="separator:a25ad0d79d7740865ddbc5a257937e405 inherit pro_attribs_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7d6c7aa1915d65af7670f4bcdf1445 inherit pro_attribs_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a0c7d6c7aa1915d65af7670f4bcdf1445">isSending</a> = false</td></tr>
<tr class="memdesc:a0c7d6c7aa1915d65af7670f4bcdf1445 inherit pro_attribs_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if we're currently publishing  <a href="class_publish_queue_async_base.html#a0c7d6c7aa1915d65af7670f4bcdf1445">More...</a><br /></td></tr>
<tr class="separator:a0c7d6c7aa1915d65af7670f4bcdf1445 inherit pro_attribs_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2223328a03338c3f8ef59dbbdb2e8fab inherit pro_attribs_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a2223328a03338c3f8ef59dbbdb2e8fab">haveSetup</a> = false</td></tr>
<tr class="memdesc:a2223328a03338c3f8ef59dbbdb2e8fab inherit pro_attribs_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if <a class="el" href="class_publish_queue_async_base.html#a1aa68c33946bf13ed4d9c15ed7e471d4" title="Start the thread. You must call this from setup. ">setup()</a> has been called.  <a href="class_publish_queue_async_base.html#a2223328a03338c3f8ef59dbbdb2e8fab">More...</a><br /></td></tr>
<tr class="separator:a2223328a03338c3f8ef59dbbdb2e8fab inherit pro_attribs_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f0e2c9b8a50fa156161ca567e29abd inherit pro_attribs_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="ae8f0e2c9b8a50fa156161ca567e29abd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#ae8f0e2c9b8a50fa156161ca567e29abd">pausePublishing</a> = false</td></tr>
<tr class="memdesc:ae8f0e2c9b8a50fa156161ca567e29abd inherit pro_attribs_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if publishing has been manually paused. <br /></td></tr>
<tr class="separator:ae8f0e2c9b8a50fa156161ca567e29abd inherit pro_attribs_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_class_publish_queue_async_base"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_class_publish_queue_async_base')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="class_publish_queue_async_base.html">PublishQueueAsyncBase</a></td></tr>
<tr class="memitem:a82da94a25de2e3d51fca16f41082c5ff inherit pub_static_attribs_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a82da94a25de2e3d51fca16f41082c5ff">EVENT_BUF_SIZE</a> = sizeof(<a class="el" href="struct_publish_queue_event_data.html">PublishQueueEventData</a>) + 65 + 623</td></tr>
<tr class="memdesc:a82da94a25de2e3d51fca16f41082c5ff inherit pub_static_attribs_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of <a class="el" href="struct_publish_queue_event_data.html" title="Event data structure. ">PublishQueueEventData</a> with strings (696 bytes)  <a href="class_publish_queue_async_base.html#a82da94a25de2e3d51fca16f41082c5ff">More...</a><br /></td></tr>
<tr class="separator:a82da94a25de2e3d51fca16f41082c5ff inherit pub_static_attribs_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_publish_queue_async_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_publish_queue_async_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_publish_queue_async_base.html">PublishQueueAsyncBase</a></td></tr>
<tr class="memitem:a7763faadc5d19fd82ea917a40d8eea35 inherit pro_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="a7763faadc5d19fd82ea917a40d8eea35"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a7763faadc5d19fd82ea917a40d8eea35">threadFunction</a> ()</td></tr>
<tr class="memdesc:a7763faadc5d19fd82ea917a40d8eea35 inherit pro_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The thread function for the publish thread. <br /></td></tr>
<tr class="separator:a7763faadc5d19fd82ea917a40d8eea35 inherit pro_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4453a1e7c146338c3a7adaf66f47e379 inherit pro_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="a4453a1e7c146338c3a7adaf66f47e379"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a4453a1e7c146338c3a7adaf66f47e379">startState</a> ()</td></tr>
<tr class="memdesc:a4453a1e7c146338c3a7adaf66f47e379 inherit pro_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker thread state machine start handler. <br /></td></tr>
<tr class="separator:a4453a1e7c146338c3a7adaf66f47e379 inherit pro_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c12f03f12cd437e1406f868b6a3158 inherit pro_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="a36c12f03f12cd437e1406f868b6a3158"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a36c12f03f12cd437e1406f868b6a3158">checkQueueState</a> ()</td></tr>
<tr class="memdesc:a36c12f03f12cd437e1406f868b6a3158 inherit pro_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker thread state machine check queue state handler. <br /></td></tr>
<tr class="separator:a36c12f03f12cd437e1406f868b6a3158 inherit pro_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd57e900a77d9250228d852fba06c26 inherit pro_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="a4dd57e900a77d9250228d852fba06c26"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a4dd57e900a77d9250228d852fba06c26">waitRetryState</a> ()</td></tr>
<tr class="memdesc:a4dd57e900a77d9250228d852fba06c26 inherit pro_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker thread state machine wait to retry publishing state handler. <br /></td></tr>
<tr class="separator:a4dd57e900a77d9250228d852fba06c26 inherit pro_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_class_publish_queue_async_base"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_class_publish_queue_async_base')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="class_publish_queue_async_base.html">PublishQueueAsyncBase</a></td></tr>
<tr class="memitem:a38f573ef4ae69b3e38a82bd3036d3e7a inherit pro_static_methods_class_publish_queue_async_base"><td class="memItemLeft" align="right" valign="top"><a id="a38f573ef4ae69b3e38a82bd3036d3e7a"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a38f573ef4ae69b3e38a82bd3036d3e7a">threadFunctionStatic</a> (void *param)</td></tr>
<tr class="memdesc:a38f573ef4ae69b3e38a82bd3036d3e7a inherit pro_static_methods_class_publish_queue_async_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static version of the thread function. <br /></td></tr>
<tr class="separator:a38f573ef4ae69b3e38a82bd3036d3e7a inherit pro_static_methods_class_publish_queue_async_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstract class for file system-based events storage (SPIFFS, SdCard, etc.) </p>
<p>All of the file systems work in a similar manner, with only a set of virtual methods like <a class="el" href="class_publish_queue_async_file_system_base.html#aecc3b4049e438d873beb731c2b894749" title="Open the events file. ">openFile()</a>, readBytes, <a class="el" href="class_publish_queue_async_file_system_base.html#a0072e34090af180dab0e5a958434eea4" title="Write bytes to the file. ">writeBytes()</a>, etc. subclasses for each concrete subclass.</p>
<p>Each operation is atomic. The mutex is obtained, the file opened, manipulated, then closed. This less efficient than keeping the file open, but is less likely to lose data if the device is reset. It also makes file system corruption less likely.</p>
<p>The file contains binary data, basically the same thing as retained memory, with a few minor changes.</p>
<p>The file begins with a file header, just like the retained memory version. It has magic bytes and other fields that can be used to check validity.</p>
<p>The size in the file header is not the size of the file, since that's unnecessary. It is, however, the number of events that have already been sent, as explained below.</p>
<p>In <a class="el" href="class_publish_queue_async_file_system.html#aa6a3bbe83d86fd514e70dd628564e5c0" title="setup() must be called from the main setup() function! ">setup()</a> the file integrity is checked. If the events file is not valid, then the contents are deleted.</p>
<p>When a publish is queued, the event is appeneded to the file and the numEvents in the header updated.</p>
<p>When a publish is completed, the size in the header (actually, the number of events sent) is incremented. If size == numEvents, then both are set to 0 and the file truncated to the size of the file header.</p>
<p>The reason for this is that unlike RAM or FRAM, it's really inefficient to remove data from the beginning of the file. Since the most common situation is that a bunch of events are queued and eventually all of them are transmitted, the code is optimized for this most common situation. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="abacc860791e7f1bcc00227cd6e784ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abacc860791e7f1bcc00227cd6e784ab9">&#9670;&nbsp;</a></span>clearEvents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PublishQueueAsyncFileSystem::clearEvents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove any saved events. </p>
<dl class="section return"><dt>Returns</dt><dd>Always returns true.</dd></dl>
<p>Since the FRAM code copies the event being published to a separate buffer, the events can always be cleared. </p>

<p>Implements <a class="el" href="class_publish_queue_async_base.html#ac9b8f93f878db4c2dfce2ab17ec4bf05">PublishQueueAsyncBase</a>.</p>

</div>
</div>
<a id="aabc8176c701a54dc67f151abfd2f86a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabc8176c701a54dc67f151abfd2f86a4">&#9670;&nbsp;</a></span>discardOldEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PublishQueueAsyncFileSystem::discardOldEvent </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>secondEvent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discard an event. </p>
<p>Note: secondEvent will never be true for file systems, which always append an event </p>

<p>Implements <a class="el" href="class_publish_queue_async_base.html#a4ff4ebefebf8f89c41b3e13641c2a2b5">PublishQueueAsyncBase</a>.</p>

</div>
</div>
<a id="a963b036bacbd8c64526d5c3598f85b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a963b036bacbd8c64526d5c3598f85b58">&#9670;&nbsp;</a></span>getOldestEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_publish_queue_event_data.html">PublishQueueEventData</a>* PublishQueueAsyncFileSystem::getOldestEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the oldest event that hasn't been published yet. </p>
<p>Returns a pointer to a <a class="el" href="struct_publish_queue_event_data.html" title="Event data structure. ">PublishQueueEventData</a> structure in the publishBuf member variable. This will remain valid until <a class="el" href="class_publish_queue_async_file_system.html#a963b036bacbd8c64526d5c3598f85b58" title="Get the oldest event that hasn&#39;t been published yet. ">getOldestEvent()</a> is called again. </p>

<p>Implements <a class="el" href="class_publish_queue_async_base.html#a010258715d59b28c1352ff56d9ccf495">PublishQueueAsyncBase</a>.</p>

</div>
</div>
<a id="aca6bfd902d13e872c3c3197d7719b3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca6bfd902d13e872c3c3197d7719b3c6">&#9670;&nbsp;</a></span>skipEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t PublishQueueAsyncFileSystem::skipEvent </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skip to the next event. </p>
<p>Note: You must obtain a mutex lock and open the events file before calling this! </p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a4f26c564e5d9fb314f7b9c92560fc701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f26c564e5d9fb314f7b9c92560fc701">&#9670;&nbsp;</a></span>eventBuf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t PublishQueueAsyncFileSystem::eventBuf[<a class="el" href="class_publish_queue_async_base.html#a82da94a25de2e3d51fca16f41082c5ff">EVENT_BUF_SIZE</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This holds a single event during scanning and writing. </p>
<p>Because the data needs to be in RAM to be written to FRAM, this buffer is required. </p>

</div>
</div>
<a id="ac7a93e1375556314518bf478245030a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a93e1375556314518bf478245030a8">&#9670;&nbsp;</a></span>oldestPos</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t PublishQueueAsyncFileSystem::oldestPos = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Offset in the file for the oldest event. We begin publishing at this offset. </p>
<p>This is set in <a class="el" href="class_publish_queue_async_file_system.html#aa6a3bbe83d86fd514e70dd628564e5c0" title="setup() must be called from the main setup() function! ">setup()</a> and updated in <a class="el" href="class_publish_queue_async_file_system.html#aabc8176c701a54dc67f151abfd2f86a4" title="Discard an event. ">discardOldEvent()</a>. </p>

</div>
</div>
<a id="ad0a6fadd941589e88baf418733d6425a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a6fadd941589e88baf418733d6425a">&#9670;&nbsp;</a></span>publishBuf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t PublishQueueAsyncFileSystem::publishBuf[<a class="el" href="class_publish_queue_async_base.html#a82da94a25de2e3d51fca16f41082c5ff">EVENT_BUF_SIZE</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This holds a single event during publish. </p>
<p>Because the publish code does not copy the data, we need to keep the data around even after <a class="el" href="class_publish_queue_async_file_system.html#a963b036bacbd8c64526d5c3598f85b58" title="Get the oldest event that hasn&#39;t been published yet. ">getOldestEvent()</a> returns. This is the buffer that holds the data.</p>
<p>It's separate from eventBuf because eventBuf is used to publish new data to the queue. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="_publish_queue_async_r_k_8h_source.html">PublishQueueAsyncRK.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
