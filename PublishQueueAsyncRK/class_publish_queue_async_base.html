<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PublishQueueAsyncRK: PublishQueueAsyncBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PublishQueueAsyncRK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">PublishQueueAsyncBase Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstract base class for async publish queue.  
 <a href="class_publish_queue_async_base.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_publish_queue_async_r_k_8h_source.html">PublishQueueAsyncRK.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PublishQueueAsyncBase:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_publish_queue_async_base.png" usemap="#PublishQueueAsyncBase_map" alt=""/>
  <map id="PublishQueueAsyncBase_map" name="PublishQueueAsyncBase_map">
<area href="class_publish_queue_async_file_system_base.html" title="Abstract base class for file system-based storage. " alt="PublishQueueAsyncFileSystemBase" shape="rect" coords="113,56,329,80"/>
<area href="class_publish_queue_async_f_r_a_m.html" title="Support for MB85RC256V-FRAM-RK library. " alt="PublishQueueAsyncFRAM" shape="rect" coords="339,56,555,80"/>
<area href="class_publish_queue_async_retained.html" title="Class to store the publish queue in retained memory. " alt="PublishQueueAsyncRetained" shape="rect" coords="565,56,781,80"/>
<area href="class_publish_queue_async_file_system.html" title="Abstract class for file system-based events storage (SPIFFS, SdCard, etc.) " alt="PublishQueueAsyncFileSystem" shape="rect" coords="113,112,329,136"/>
<area href="class_publish_queue_async.html" title="Backward compatible API so code build for version 0.0.5 and earlier will still compile. " alt="PublishQueueAsync" shape="rect" coords="565,112,781,136"/>
<area href="class_publish_queue_async_sd_fat.html" title="Concrete subclass for storing events on a SdFat file system. " alt="PublishQueueAsyncSdFat" shape="rect" coords="0,168,216,192"/>
<area href="class_publish_queue_async_spiffs.html" title="Concrete subclass to store events on SPIFFS file system. " alt="PublishQueueAsyncSpiffs" shape="rect" coords="226,168,442,192"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0f99925ab8cba714e54364adb80a2582"><td class="memItemLeft" align="right" valign="top"><a id="a0f99925ab8cba714e54364adb80a2582"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a0f99925ab8cba714e54364adb80a2582">PublishQueueAsyncBase</a> ()</td></tr>
<tr class="memdesc:a0f99925ab8cba714e54364adb80a2582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a publish queue. <br /></td></tr>
<tr class="separator:a0f99925ab8cba714e54364adb80a2582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29fb8c23ba93bbade9c176fce84ef9c"><td class="memItemLeft" align="right" valign="top"><a id="ae29fb8c23ba93bbade9c176fce84ef9c"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#ae29fb8c23ba93bbade9c176fce84ef9c">~PublishQueueAsyncBase</a> ()</td></tr>
<tr class="memdesc:ae29fb8c23ba93bbade9c176fce84ef9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">You normally allocate this as a global object and never delete it. <br /></td></tr>
<tr class="separator:ae29fb8c23ba93bbade9c176fce84ef9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa68c33946bf13ed4d9c15ed7e471d4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a1aa68c33946bf13ed4d9c15ed7e471d4">setup</a> ()</td></tr>
<tr class="memdesc:a1aa68c33946bf13ed4d9c15ed7e471d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the thread. You must call this from setup.  <a href="#a1aa68c33946bf13ed4d9c15ed7e471d4">More...</a><br /></td></tr>
<tr class="separator:a1aa68c33946bf13ed4d9c15ed7e471d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b6306491fc1c4993677f7a09373040"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#ab9b6306491fc1c4993677f7a09373040">publish</a> (const char *eventName, PublishFlags flags1, PublishFlags flags2=PublishFlags())</td></tr>
<tr class="memdesc:ab9b6306491fc1c4993677f7a09373040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for publishing an event.  <a href="#ab9b6306491fc1c4993677f7a09373040">More...</a><br /></td></tr>
<tr class="separator:ab9b6306491fc1c4993677f7a09373040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd76b1db3e72968c899a6d25cda385ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#abd76b1db3e72968c899a6d25cda385ac">publish</a> (const char *eventName, const char *data, PublishFlags flags1, PublishFlags flags2=PublishFlags())</td></tr>
<tr class="memdesc:abd76b1db3e72968c899a6d25cda385ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for publishing an event.  <a href="#abd76b1db3e72968c899a6d25cda385ac">More...</a><br /></td></tr>
<tr class="separator:abd76b1db3e72968c899a6d25cda385ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386c05f3d4f78e8b18d52c77fcd7d03a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a386c05f3d4f78e8b18d52c77fcd7d03a">publish</a> (const char *eventName, const char *data, int ttl, PublishFlags flags1, PublishFlags flags2=PublishFlags())</td></tr>
<tr class="memdesc:a386c05f3d4f78e8b18d52c77fcd7d03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for publishing an event.  <a href="#a386c05f3d4f78e8b18d52c77fcd7d03a">More...</a><br /></td></tr>
<tr class="separator:a386c05f3d4f78e8b18d52c77fcd7d03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd5556a87ef87adacb215f7b9ae03af"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a9fd5556a87ef87adacb215f7b9ae03af">publishCommon</a> (const char *eventName, const char *data, int ttl, PublishFlags flags1, PublishFlags flags2=PublishFlags())=0</td></tr>
<tr class="memdesc:a9fd5556a87ef87adacb215f7b9ae03af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common publish function. All other overloads lead here. This is a pure virtual function, implemented in subclasses.  <a href="#a9fd5556a87ef87adacb215f7b9ae03af">More...</a><br /></td></tr>
<tr class="separator:a9fd5556a87ef87adacb215f7b9ae03af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293b9cbbb28c8df2ee3d4dcd631c8288"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_publish_queue_async_base.html">PublishQueueAsyncBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a293b9cbbb28c8df2ee3d4dcd631c8288">withFailureRetryMs</a> (unsigned long value)</td></tr>
<tr class="memdesc:a293b9cbbb28c8df2ee3d4dcd631c8288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the retry after publish failure time.  <a href="#a293b9cbbb28c8df2ee3d4dcd631c8288">More...</a><br /></td></tr>
<tr class="separator:a293b9cbbb28c8df2ee3d4dcd631c8288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b8f93f878db4c2dfce2ab17ec4bf05"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#ac9b8f93f878db4c2dfce2ab17ec4bf05">clearEvents</a> ()=0</td></tr>
<tr class="memdesc:ac9b8f93f878db4c2dfce2ab17ec4bf05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove any saved events.  <a href="#ac9b8f93f878db4c2dfce2ab17ec4bf05">More...</a><br /></td></tr>
<tr class="separator:ac9b8f93f878db4c2dfce2ab17ec4bf05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010258715d59b28c1352ff56d9ccf495"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_publish_queue_event_data.html">PublishQueueEventData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a010258715d59b28c1352ff56d9ccf495">getOldestEvent</a> ()=0</td></tr>
<tr class="memdesc:a010258715d59b28c1352ff56d9ccf495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the oldest event that hasn't been published yet.  <a href="#a010258715d59b28c1352ff56d9ccf495">More...</a><br /></td></tr>
<tr class="separator:a010258715d59b28c1352ff56d9ccf495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff4ebefebf8f89c41b3e13641c2a2b5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a4ff4ebefebf8f89c41b3e13641c2a2b5">discardOldEvent</a> (bool secondEvent)=0</td></tr>
<tr class="memdesc:a4ff4ebefebf8f89c41b3e13641c2a2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discards the oldest event or second oldest event.  <a href="#a4ff4ebefebf8f89c41b3e13641c2a2b5">More...</a><br /></td></tr>
<tr class="separator:a4ff4ebefebf8f89c41b3e13641c2a2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70c0a7eada8a75ea376b134baf66dd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#aa70c0a7eada8a75ea376b134baf66dd0">setPausePublishing</a> (bool pause)</td></tr>
<tr class="memdesc:aa70c0a7eada8a75ea376b134baf66dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause publishing, even if it would be allowed because the cloud is connected.  <a href="#aa70c0a7eada8a75ea376b134baf66dd0">More...</a><br /></td></tr>
<tr class="separator:aa70c0a7eada8a75ea376b134baf66dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8da81748f9fdb1925254a67126f465e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#ab8da81748f9fdb1925254a67126f465e">getPausePublishing</a> () const</td></tr>
<tr class="memdesc:ab8da81748f9fdb1925254a67126f465e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if publishing is manually paused.  <a href="#ab8da81748f9fdb1925254a67126f465e">More...</a><br /></td></tr>
<tr class="separator:ab8da81748f9fdb1925254a67126f465e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4e10fcf529d6d477cda3a2abb0a2ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a4e4e10fcf529d6d477cda3a2abb0a2ff">mutexLock</a> () const</td></tr>
<tr class="memdesc:a4e4e10fcf529d6d477cda3a2abb0a2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a mutex lock.  <a href="#a4e4e10fcf529d6d477cda3a2abb0a2ff">More...</a><br /></td></tr>
<tr class="separator:a4e4e10fcf529d6d477cda3a2abb0a2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3410502e46602fe26aa2fe372663119"><td class="memItemLeft" align="right" valign="top"><a id="af3410502e46602fe26aa2fe372663119"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#af3410502e46602fe26aa2fe372663119">mutexUnlock</a> () const</td></tr>
<tr class="memdesc:af3410502e46602fe26aa2fe372663119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the mutex. <br /></td></tr>
<tr class="separator:af3410502e46602fe26aa2fe372663119"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a82da94a25de2e3d51fca16f41082c5ff"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a82da94a25de2e3d51fca16f41082c5ff">EVENT_BUF_SIZE</a> = sizeof(<a class="el" href="struct_publish_queue_event_data.html">PublishQueueEventData</a>) + 65 + 623</td></tr>
<tr class="memdesc:a82da94a25de2e3d51fca16f41082c5ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of <a class="el" href="struct_publish_queue_event_data.html" title="Event data structure. ">PublishQueueEventData</a> with strings (696 bytes)  <a href="#a82da94a25de2e3d51fca16f41082c5ff">More...</a><br /></td></tr>
<tr class="separator:a82da94a25de2e3d51fca16f41082c5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7763faadc5d19fd82ea917a40d8eea35"><td class="memItemLeft" align="right" valign="top"><a id="a7763faadc5d19fd82ea917a40d8eea35"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a7763faadc5d19fd82ea917a40d8eea35">threadFunction</a> ()</td></tr>
<tr class="memdesc:a7763faadc5d19fd82ea917a40d8eea35"><td class="mdescLeft">&#160;</td><td class="mdescRight">The thread function for the publish thread. <br /></td></tr>
<tr class="separator:a7763faadc5d19fd82ea917a40d8eea35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4453a1e7c146338c3a7adaf66f47e379"><td class="memItemLeft" align="right" valign="top"><a id="a4453a1e7c146338c3a7adaf66f47e379"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a4453a1e7c146338c3a7adaf66f47e379">startState</a> ()</td></tr>
<tr class="memdesc:a4453a1e7c146338c3a7adaf66f47e379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker thread state machine start handler. <br /></td></tr>
<tr class="separator:a4453a1e7c146338c3a7adaf66f47e379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c12f03f12cd437e1406f868b6a3158"><td class="memItemLeft" align="right" valign="top"><a id="a36c12f03f12cd437e1406f868b6a3158"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a36c12f03f12cd437e1406f868b6a3158">checkQueueState</a> ()</td></tr>
<tr class="memdesc:a36c12f03f12cd437e1406f868b6a3158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker thread state machine check queue state handler. <br /></td></tr>
<tr class="separator:a36c12f03f12cd437e1406f868b6a3158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd57e900a77d9250228d852fba06c26"><td class="memItemLeft" align="right" valign="top"><a id="a4dd57e900a77d9250228d852fba06c26"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a4dd57e900a77d9250228d852fba06c26">waitRetryState</a> ()</td></tr>
<tr class="memdesc:a4dd57e900a77d9250228d852fba06c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker thread state machine wait to retry publishing state handler. <br /></td></tr>
<tr class="separator:a4dd57e900a77d9250228d852fba06c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a38f573ef4ae69b3e38a82bd3036d3e7a"><td class="memItemLeft" align="right" valign="top"><a id="a38f573ef4ae69b3e38a82bd3036d3e7a"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a38f573ef4ae69b3e38a82bd3036d3e7a">threadFunctionStatic</a> (void *param)</td></tr>
<tr class="memdesc:a38f573ef4ae69b3e38a82bd3036d3e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static version of the thread function. <br /></td></tr>
<tr class="separator:a38f573ef4ae69b3e38a82bd3036d3e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a72689e01ab54e418c06bcd110b042bc6"><td class="memItemLeft" align="right" valign="top"><a id="a72689e01ab54e418c06bcd110b042bc6"></a>
Thread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a72689e01ab54e418c06bcd110b042bc6">thread</a> = NULL</td></tr>
<tr class="memdesc:a72689e01ab54e418c06bcd110b042bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread object, created in <a class="el" href="class_publish_queue_async_base.html#a1aa68c33946bf13ed4d9c15ed7e471d4" title="Start the thread. You must call this from setup. ">setup()</a> <br /></td></tr>
<tr class="separator:a72689e01ab54e418c06bcd110b042bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f9981e0546e787ca6efc0253d36050"><td class="memItemLeft" align="right" valign="top"><a id="a00f9981e0546e787ca6efc0253d36050"></a>
os_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a00f9981e0546e787ca6efc0253d36050">mutex</a></td></tr>
<tr class="memdesc:a00f9981e0546e787ca6efc0253d36050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex to protect against concurrent access, created in <a class="el" href="class_publish_queue_async_base.html#a1aa68c33946bf13ed4d9c15ed7e471d4" title="Start the thread. You must call this from setup. ">setup()</a> <br /></td></tr>
<tr class="separator:a00f9981e0546e787ca6efc0253d36050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325d1178a41cd127817ccd642e36e4f0"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a325d1178a41cd127817ccd642e36e4f0">failureRetryMs</a> = 30000</td></tr>
<tr class="memdesc:a325d1178a41cd127817ccd642e36e4f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default time to wait before trying to publish again after failure.  <a href="#a325d1178a41cd127817ccd642e36e4f0">More...</a><br /></td></tr>
<tr class="separator:a325d1178a41cd127817ccd642e36e4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d1c3bfb3f31f4149f6f77240b7b805"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="class_publish_queue_async_base.html">PublishQueueAsyncBase</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a84d1c3bfb3f31f4149f6f77240b7b805">stateHandler</a> = &amp;<a class="el" href="class_publish_queue_async_base.html#a4453a1e7c146338c3a7adaf66f47e379">PublishQueueAsyncBase::startState</a></td></tr>
<tr class="memdesc:a84d1c3bfb3f31f4149f6f77240b7b805"><td class="mdescLeft">&#160;</td><td class="mdescRight">State handler function pointer.  <a href="#a84d1c3bfb3f31f4149f6f77240b7b805">More...</a><br /></td></tr>
<tr class="separator:a84d1c3bfb3f31f4149f6f77240b7b805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac136d0f2dd73551add270db06414ef18"><td class="memItemLeft" align="right" valign="top"><a id="ac136d0f2dd73551add270db06414ef18"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#ac136d0f2dd73551add270db06414ef18">stateTime</a> = 0</td></tr>
<tr class="memdesc:ac136d0f2dd73551add270db06414ef18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last millis value for certain state changes like waitRetryState. <br /></td></tr>
<tr class="separator:ac136d0f2dd73551add270db06414ef18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ad0d79d7740865ddbc5a257937e405"><td class="memItemLeft" align="right" valign="top"><a id="a25ad0d79d7740865ddbc5a257937e405"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a25ad0d79d7740865ddbc5a257937e405">lastPublish</a> = 0</td></tr>
<tr class="memdesc:a25ad0d79d7740865ddbc5a257937e405"><td class="mdescLeft">&#160;</td><td class="mdescRight">milis() value for the last publish, used to control the frequency of publishes <br /></td></tr>
<tr class="separator:a25ad0d79d7740865ddbc5a257937e405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7d6c7aa1915d65af7670f4bcdf1445"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a0c7d6c7aa1915d65af7670f4bcdf1445">isSending</a> = false</td></tr>
<tr class="memdesc:a0c7d6c7aa1915d65af7670f4bcdf1445"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if we're currently publishing  <a href="#a0c7d6c7aa1915d65af7670f4bcdf1445">More...</a><br /></td></tr>
<tr class="separator:a0c7d6c7aa1915d65af7670f4bcdf1445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2223328a03338c3f8ef59dbbdb2e8fab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#a2223328a03338c3f8ef59dbbdb2e8fab">haveSetup</a> = false</td></tr>
<tr class="memdesc:a2223328a03338c3f8ef59dbbdb2e8fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if <a class="el" href="class_publish_queue_async_base.html#a1aa68c33946bf13ed4d9c15ed7e471d4" title="Start the thread. You must call this from setup. ">setup()</a> has been called.  <a href="#a2223328a03338c3f8ef59dbbdb2e8fab">More...</a><br /></td></tr>
<tr class="separator:a2223328a03338c3f8ef59dbbdb2e8fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f0e2c9b8a50fa156161ca567e29abd"><td class="memItemLeft" align="right" valign="top"><a id="ae8f0e2c9b8a50fa156161ca567e29abd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_async_base.html#ae8f0e2c9b8a50fa156161ca567e29abd">pausePublishing</a> = false</td></tr>
<tr class="memdesc:ae8f0e2c9b8a50fa156161ca567e29abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if publishing has been manually paused. <br /></td></tr>
<tr class="separator:ae8f0e2c9b8a50fa156161ca567e29abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstract base class for async publish queue. </p>
<p>You don't instantiate one of these, you instead instantitate a concrete subclass like:</p><ul>
<li><a class="el" href="class_publish_queue_async_retained.html" title="Class to store the publish queue in retained memory. ">PublishQueueAsyncRetained</a></li>
<li><a class="el" href="class_publish_queue_async_f_r_a_m.html" title="Support for MB85RC256V-FRAM-RK library. ">PublishQueueAsyncFRAM</a></li>
<li><a class="el" href="class_publish_queue_async_spiffs.html" title="Concrete subclass to store events on SPIFFS file system. ">PublishQueueAsyncSpiffs</a></li>
<li><a class="el" href="class_publish_queue_async_sd_fat.html" title="Concrete subclass for storing events on a SdFat file system. ">PublishQueueAsyncSdFat</a> </li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ac9b8f93f878db4c2dfce2ab17ec4bf05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b8f93f878db4c2dfce2ab17ec4bf05">&#9670;&nbsp;</a></span>clearEvents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PublishQueueAsyncBase::clearEvents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove any saved events. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the operation succeeded, or false if an event is currently being sent so the events cannot be deleted. </dd></dl>

<p>Implemented in <a class="el" href="class_publish_queue_async_file_system.html#abacc860791e7f1bcc00227cd6e784ab9">PublishQueueAsyncFileSystem</a>, <a class="el" href="class_publish_queue_async_f_r_a_m.html#af068a2531ce0516bdba3dcaf30ced498">PublishQueueAsyncFRAM</a>, and <a class="el" href="class_publish_queue_async_retained.html#af43b9eb856d90539ff5caacd3fbe46e0">PublishQueueAsyncRetained</a>.</p>

</div>
</div>
<a id="a4ff4ebefebf8f89c41b3e13641c2a2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff4ebefebf8f89c41b3e13641c2a2b5">&#9670;&nbsp;</a></span>discardOldEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PublishQueueAsyncBase::discardOldEvent </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>secondEvent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discards the oldest event or second oldest event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">secondEvent</td><td>True to discard the second oldest event</td></tr>
  </table>
  </dd>
</dl>
<p>When using retained memory, the <a class="el" href="class_publish_queue_async_base.html#a010258715d59b28c1352ff56d9ccf495" title="Get the oldest event that hasn&#39;t been published yet. ">getOldestEvent()</a> function returns a pointer to retained memory. This pointer must remain valid while in the process of publishing. If the retained buffer is full, we want to discard and old event to make room for a newer event, but we can't dispose of the oldest event, because it may be in use, so we pass true for secondEvent.</p>
<p>After successfully publishingm this is called with secondEvent = false to discard the event we just published.</p>
<p>For file systems (SPIFFS and SdCard), secondEvent is never set to true. </p>

<p>Implemented in <a class="el" href="class_publish_queue_async_file_system.html#aabc8176c701a54dc67f151abfd2f86a4">PublishQueueAsyncFileSystem</a>, <a class="el" href="class_publish_queue_async_f_r_a_m.html#a3b23a7caaf7e70689217fd5ce9fd9d73">PublishQueueAsyncFRAM</a>, and <a class="el" href="class_publish_queue_async_retained.html#a86d93482fd77f1cf4a33f0d7494b406b">PublishQueueAsyncRetained</a>.</p>

</div>
</div>
<a id="a010258715d59b28c1352ff56d9ccf495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a010258715d59b28c1352ff56d9ccf495">&#9670;&nbsp;</a></span>getOldestEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_publish_queue_event_data.html">PublishQueueEventData</a>* PublishQueueAsyncBase::getOldestEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the oldest event that hasn't been published yet. </p>
<p>Returns a pointer to a <a class="el" href="struct_publish_queue_event_data.html" title="Event data structure. ">PublishQueueEventData</a> structure. This will remain valid until <a class="el" href="class_publish_queue_async_base.html#a010258715d59b28c1352ff56d9ccf495" title="Get the oldest event that hasn&#39;t been published yet. ">getOldestEvent()</a> is called again. </p>

<p>Implemented in <a class="el" href="class_publish_queue_async_file_system.html#a963b036bacbd8c64526d5c3598f85b58">PublishQueueAsyncFileSystem</a>, <a class="el" href="class_publish_queue_async_f_r_a_m.html#a778e30bcaef0c1f171a1571f10d88586">PublishQueueAsyncFRAM</a>, and <a class="el" href="class_publish_queue_async_retained.html#a6b5db84095bf507fc93de724e434105f">PublishQueueAsyncRetained</a>.</p>

</div>
</div>
<a id="ab8da81748f9fdb1925254a67126f465e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8da81748f9fdb1925254a67126f465e">&#9670;&nbsp;</a></span>getPausePublishing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PublishQueueAsyncBase::getPausePublishing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if publishing is manually paused. </p>
<p>It does not take into account the cloud connection state, only manual pausing. </p>

</div>
</div>
<a id="a4e4e10fcf529d6d477cda3a2abb0a2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4e10fcf529d6d477cda3a2abb0a2ff">&#9670;&nbsp;</a></span>mutexLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PublishQueueAsyncBase::mutexLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a mutex lock. </p>
<p>This is done before any operation that modifies the retianed buffer or other shared resources, typically using the <a class="el" href="class_st_mutex_lock.html" title="Class to automatically lock and unlock the mutex. Create as a variable on the stack. ">StMutexLock</a> class instead of calling <a class="el" href="class_publish_queue_async_base.html#a4e4e10fcf529d6d477cda3a2abb0a2ff" title="Obtain a mutex lock. ">mutexLock()</a> and <a class="el" href="class_publish_queue_async_base.html#af3410502e46602fe26aa2fe372663119" title="Unlock the mutex. ">mutexUnlock()</a> directly.</p>
<p>Prior to version 0.1.0 there was no mutex and SINGLE_THREADED_BLOCK was used, but the mutex is more efficient and safer. When using a SINGLE_THREADED_BLOCK there is a greater chance of accidentally causing deadlock. </p>

</div>
</div>
<a id="ab9b6306491fc1c4993677f7a09373040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9b6306491fc1c4993677f7a09373040">&#9670;&nbsp;</a></span>publish() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PublishQueueAsyncBase::publish </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eventName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublishFlags&#160;</td>
          <td class="paramname"><em>flags1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublishFlags&#160;</td>
          <td class="paramname"><em>flags2</em> = <code>PublishFlags()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for publishing an event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventName</td><td>The name of the event (63 character maximum).</td></tr>
    <tr><td class="paramname">flags1</td><td>Normally PRIVATE. You can also use PUBLIC, but one or the other must be specified.</td></tr>
    <tr><td class="paramname">flags2</td><td>(optional) You can use NO_ACK or WITH_ACK if desired.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the event was queued or false if it was not.</dd></dl>
<p>This function almost always returns true. If you queue more events than fit in the buffer the oldest (sometimes second oldest) is discarded. </p>

</div>
</div>
<a id="abd76b1db3e72968c899a6d25cda385ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd76b1db3e72968c899a6d25cda385ac">&#9670;&nbsp;</a></span>publish() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PublishQueueAsyncBase::publish </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eventName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublishFlags&#160;</td>
          <td class="paramname"><em>flags1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublishFlags&#160;</td>
          <td class="paramname"><em>flags2</em> = <code>PublishFlags()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for publishing an event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventName</td><td>The name of the event (63 character maximum).</td></tr>
    <tr><td class="paramname">data</td><td>The event data (255 bytes maximum, 622 bytes in system firmware 0.8.0-rc.4 and later).</td></tr>
    <tr><td class="paramname">flags1</td><td>Normally PRIVATE. You can also use PUBLIC, but one or the other must be specified.</td></tr>
    <tr><td class="paramname">flags2</td><td>(optional) You can use NO_ACK or WITH_ACK if desired.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the event was queued or false if it was not.</dd></dl>
<p>This function almost always returns true. If you queue more events than fit in the buffer the oldest (sometimes second oldest) is discarded. </p>

</div>
</div>
<a id="a386c05f3d4f78e8b18d52c77fcd7d03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386c05f3d4f78e8b18d52c77fcd7d03a">&#9670;&nbsp;</a></span>publish() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PublishQueueAsyncBase::publish </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eventName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ttl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublishFlags&#160;</td>
          <td class="paramname"><em>flags1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublishFlags&#160;</td>
          <td class="paramname"><em>flags2</em> = <code>PublishFlags()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for publishing an event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventName</td><td>The name of the event (63 character maximum).</td></tr>
    <tr><td class="paramname">data</td><td>The event data (255 bytes maximum, 622 bytes in system firmware 0.8.0-rc.4 and later).</td></tr>
    <tr><td class="paramname">ttl</td><td>The time-to-live value. If not specified in one of the other overloads, the value 60 is used. However, the ttl is ignored by the cloud, so it doesn't matter what you set it to. Essentially all events are discarded immediately if not subscribed to so they essentially have a ttl of 0.</td></tr>
    <tr><td class="paramname">flags1</td><td>Normally PRIVATE. You can also use PUBLIC, but one or the other must be specified.</td></tr>
    <tr><td class="paramname">flags2</td><td>(optional) You can use NO_ACK or WITH_ACK if desired.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the event was queued or false if it was not.</dd></dl>
<p>This function almost always returns true. If you queue more events than fit in the buffer the oldest (sometimes second oldest) is discarded. </p>

</div>
</div>
<a id="a9fd5556a87ef87adacb215f7b9ae03af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd5556a87ef87adacb215f7b9ae03af">&#9670;&nbsp;</a></span>publishCommon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PublishQueueAsyncBase::publishCommon </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eventName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ttl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublishFlags&#160;</td>
          <td class="paramname"><em>flags1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublishFlags&#160;</td>
          <td class="paramname"><em>flags2</em> = <code>PublishFlags()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Common publish function. All other overloads lead here. This is a pure virtual function, implemented in subclasses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventName</td><td>The name of the event (63 character maximum).</td></tr>
    <tr><td class="paramname">data</td><td>The event data (255 bytes maximum, 622 bytes in system firmware 0.8.0-rc.4 and later).</td></tr>
    <tr><td class="paramname">ttl</td><td>The time-to-live value. If not specified in one of the other overloads, the value 60 is used. However, the ttl is ignored by the cloud, so it doesn't matter what you set it to. Essentially all events are discarded immediately if not subscribed to so they essentially have a ttl of 0.</td></tr>
    <tr><td class="paramname">flags1</td><td>Normally PRIVATE. You can also use PUBLIC, but one or the other must be specified.</td></tr>
    <tr><td class="paramname">flags2</td><td>(optional) You can use NO_ACK or WITH_ACK if desired.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the event was queued or false if it was not.</dd></dl>
<p>This function almost always returns true. If you queue more events than fit in the buffer the oldest (sometimes second oldest) is discarded. </p>

<p>Implemented in <a class="el" href="class_publish_queue_async_file_system.html#a08f7751626b59b342ddafb70744885b4">PublishQueueAsyncFileSystem</a>, <a class="el" href="class_publish_queue_async_f_r_a_m.html#ab38d3734e5480be842062a74c4b4cbac">PublishQueueAsyncFRAM</a>, and <a class="el" href="class_publish_queue_async_retained.html#a094ca07795be1f7a5c694090d5c294db">PublishQueueAsyncRetained</a>.</p>

</div>
</div>
<a id="aa70c0a7eada8a75ea376b134baf66dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70c0a7eada8a75ea376b134baf66dd0">&#9670;&nbsp;</a></span>setPausePublishing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PublishQueueAsyncBase::setPausePublishing </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pause</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pause publishing, even if it would be allowed because the cloud is connected. </p>
<p>This is used by the test suite, or you could use it in special cases. </p>

</div>
</div>
<a id="a1aa68c33946bf13ed4d9c15ed7e471d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa68c33946bf13ed4d9c15ed7e471d4">&#9670;&nbsp;</a></span>setup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PublishQueueAsyncBase::setup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start the thread. You must call this from setup. </p>
<p>Since version 0.0.1 did not have the setup method, if you don't <a class="el" href="class_publish_queue_async_base.html#a1aa68c33946bf13ed4d9c15ed7e471d4" title="Start the thread. You must call this from setup. ">setup()</a> it will be set up when you first publish, but starting the thread earlier is suggested, but only with retained memory (<a class="el" href="class_publish_queue_async.html" title="Backward compatible API so code build for version 0.0.5 and earlier will still compile. ">PublishQueueAsync</a>).</p>
<p>In 0.1.0 or later you must call <a class="el" href="class_publish_queue_async_base.html#a1aa68c33946bf13ed4d9c15ed7e471d4" title="Start the thread. You must call this from setup. ">setup()</a>, or the library will not function with FRAM, Spiffs, or SdFat. </p>

<p>Reimplemented in <a class="el" href="class_publish_queue_async_file_system.html#aa6a3bbe83d86fd514e70dd628564e5c0">PublishQueueAsyncFileSystem</a>, and <a class="el" href="class_publish_queue_async_f_r_a_m.html#a013ceb1b5b448878285371c60638457f">PublishQueueAsyncFRAM</a>.</p>

</div>
</div>
<a id="a293b9cbbb28c8df2ee3d4dcd631c8288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a293b9cbbb28c8df2ee3d4dcd631c8288">&#9670;&nbsp;</a></span>withFailureRetryMs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_publish_queue_async_base.html">PublishQueueAsyncBase</a>&amp; PublishQueueAsyncBase::withFailureRetryMs </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the retry after publish failure time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The time in milliseconds (default: 30000, or 30 seconds)</td></tr>
  </table>
  </dd>
</dl>
<p>If a publish fails, this is the amount of time to wait before trying to send the event again. </p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a82da94a25de2e3d51fca16f41082c5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82da94a25de2e3d51fca16f41082c5ff">&#9670;&nbsp;</a></span>EVENT_BUF_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t PublishQueueAsyncBase::EVENT_BUF_SIZE = sizeof(<a class="el" href="struct_publish_queue_event_data.html">PublishQueueEventData</a>) + 65 + 623</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum size of <a class="el" href="struct_publish_queue_event_data.html" title="Event data structure. ">PublishQueueEventData</a> with strings (696 bytes) </p>
<p><a class="el" href="struct_publish_queue_event_data.html" title="Event data structure. ">PublishQueueEventData</a> contains flags and ttl (8 bytes) 65 is the maximum event name length (64) + trailing null 623 is the maximum event value length (622) + trailing null It's padded to a 4-byte boundary, by 696 is already at a 4-byte boundary</p>
<p>Note: This size is not used for the retained memory subclass, but since it's used by multiple other subclasses, it's included here. </p>

</div>
</div>
<a id="a325d1178a41cd127817ccd642e36e4f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a325d1178a41cd127817ccd642e36e4f0">&#9670;&nbsp;</a></span>failureRetryMs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long PublishQueueAsyncBase::failureRetryMs = 30000</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default time to wait before trying to publish again after failure. </p>
<p>Default is 30000 milliseconds (30 seconds) </p>

</div>
</div>
<a id="a2223328a03338c3f8ef59dbbdb2e8fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2223328a03338c3f8ef59dbbdb2e8fab">&#9670;&nbsp;</a></span>haveSetup</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PublishQueueAsyncBase::haveSetup = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if <a class="el" href="class_publish_queue_async_base.html#a1aa68c33946bf13ed4d9c15ed7e471d4" title="Start the thread. You must call this from setup. ">setup()</a> has been called. </p>
<p>You should always call the <a class="el" href="class_publish_queue_async_base.html#a1aa68c33946bf13ed4d9c15ed7e471d4" title="Start the thread. You must call this from setup. ">setup()</a> method from <a class="el" href="class_publish_queue_async_base.html#a1aa68c33946bf13ed4d9c15ed7e471d4" title="Start the thread. You must call this from setup. ">setup()</a>. </p>

</div>
</div>
<a id="a0c7d6c7aa1915d65af7670f4bcdf1445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c7d6c7aa1915d65af7670f4bcdf1445">&#9670;&nbsp;</a></span>isSending</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PublishQueueAsyncBase::isSending = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>true if we're currently publishing </p>
<p>This is used to control whether we discard the oldest or second oldest event if the retained buffer is full. </p>

</div>
</div>
<a id="a84d1c3bfb3f31f4149f6f77240b7b805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84d1c3bfb3f31f4149f6f77240b7b805">&#9670;&nbsp;</a></span>stateHandler</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(<a class="el" href="class_publish_queue_async_base.html">PublishQueueAsyncBase</a>&amp;)&gt; PublishQueueAsyncBase::stateHandler = &amp;<a class="el" href="class_publish_queue_async_base.html#a4453a1e7c146338c3a7adaf66f47e379">PublishQueueAsyncBase::startState</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>State handler function pointer. </p>
<p>Set to startState, checkQueueState, or waitRetryState </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_publish_queue_async_r_k_8h_source.html">PublishQueueAsyncRK.h</a></li>
<li>src/PublishQueueAsyncRK.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
